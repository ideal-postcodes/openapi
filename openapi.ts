/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/postcodes/{postcode}": {
    /**
     * Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
     *
     * The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
     *
     * ## Postcode Not Found
     *
     * Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
     *
     * ```json
     * {
     *   "code": 4040,
     *   "message": "Postcode not found",
     *   "suggestions": ["SW1A 0AA"]
     * }
     * ```
     *
     * ### Suggestions
     *
     * If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
     *
     * If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
     *
     * The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
     *
     * ## Multiple Residence
     *
     * A small number of postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
     */
    get: operations["Postcodes"];
  };
  "/udprn/{udprn}": {
    /**
     * Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
     *
     * You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
     *
     * UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
     *
     * ## Testing
     *
     * To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
     *
     * They are the following:
     *
     * - `0` Returns a successful UDPRN lookup response
     *   `2000`
     * - `-1` Returns "UDPRN not found", error `4044`
     * - `-2` Returns "no lookups remaining", error `4020`
     * - `-3` Returns "daily (or individual) lookup limit breached",
     *   error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["UDPRN"];
  };
  "/umprn/{umprn}": {
    /**
     * Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
     *
     * UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
     *
     * ## Testing
     *
     * To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
     *
     * - `0` Returns a successful UMPRN lookup response `2000`
     * - `-1` Returns "UMPRN not found", error `4044`
     * - `-2` Returns "no lookups remaining", error `4020`
     * - `-3` Returns "daily (or individual) lookup limit breached", error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     *
     * ### Pricing
     *
     * Per lookup charges apply. Empty responses are not charged.
     */
    get: operations["UMPRN"];
  };
  "/keys/{key}": {
    /**
     * Returns public information on key. Currently only returns whether the key is currently useable via the `available` property. Use this to discover if the key is useable before making further requests.
     *
     * You may pass both API Keys (beginning `ak_`) and Sub-licensed Keys (beginning `sl_`).
     * ## Testing
     *
     * To test your implementation of our API, you may use the following test keys.
     *
     * - **iddqd** Availability will return as `true`
     * - **idkfa** Availability will return as `false`
     */
    get: operations["KeyAvailability"];
  };
  "/keys/{key}/details": {
    /** Returns private data on the key including remaining lookups, available datasets and usage limits. */
    get: operations["KeyDetails"];
  };
  "/keys/{key}/usage": {
    /**
     * Reports the number of lookups consumed on a key for a range of days.
     *
     * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
     */
    get: operations["KeyUsage"];
  };
  "/keys/{key}/lookups": {
    /**
     * Reports lookup information on a key for paid lookups.
     *
     * This method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).
     *
     * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
     *
     * ## Download Usage History (CSV)
     *
     * `GET /keys/:key/lookups`
     *
     * Returns a CSV download of lookups performed and associated information.
     *
     * Note that the Content-Type returned will be CSV (text/csv). For a non 200 response, the `Content-Type` will revert to JSON with the error code and message embedded.
     *
     * ## Data Redaction
     *
     * Personally Identifiable Data (PII) caught in this your usage log (including IP, search term and URL data) will be redacted on a weekly basis.
     *
     * By default, PII will be redacted if it is older than 21 days. This timeframe can be configured from your dashboard.
     *
     * You may prevent PII collection altogether by setting the interval to `0` days.
     */
    get: operations["KeyLogs"];
  };
  "/autocomplete/addresses": {
    /**
     * The address autocomplete API returns a list of address suggestions that match the query ordered by relevance.
     *
     * This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
     *
     * Consider using our Address Autocomplete JavaScript libraries to add address lookup to a form in moments.
     *
     * ## Implementing Address Autocomplete
     *
     * Rapid address autocompletion using our Address Autocomplete API is a 2 step process.
     *
     * 1. Retrieve partial address suggestions via `/autocomplete/addresses`
     * 2. Retrieve the entire address with the ID provided in the suggestion
     *
     * Step 2 will decrement your lookup balance.
     *
     * Please note, this API is not intended to be a free standalone resource.
     *
     * ## Filters
     *
     * You can strictly narrow your result by adding filters to your querystring. For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
     *
     * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
     *
     * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
     *
     * All filters can accept multiple terms unless stated otherwise below.
     *
     * Filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
     *
     * A maximum of **10** terms are allowed across all filters.
     *
     * ## Biases
     *
     * You can boost certain addresses results that match specific address criteria. All bias searches are prefixed with `bias_`.
     *
     * Biasing (unlike filtering) also allow unmatched addresses to appear with lower precedence.
     *
     * For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
     *
     * No bias effect applies to bias terms that are invalid. e.g. `bias_postcode=SW1A2AAA`
     *
     * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
     *
     * All biases can accept multiple terms unless stated otherwise below.
     *
     * A combined maximum of **5** terms are allowed across all biases.
     *
     * ## Suggestion Format
     *
     * The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
     *
     * ## Rate Limiting
     *
     * You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
     *
     * | Header                  | Description                                                                            |
     * | ----------------------- | -------------------------------------------------------------------------------------- |
     * | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
     * | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
     * | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
     *
     * ## Pricing
     *
     * This API currently does not affect your balance. However, resolving a suggestion into a full address requires a paid request.
     *
     * Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
     */
    get: operations["AddressAutocomplete"];
  };
  "/autocomplete/addresses/{address}/gbr": {
    /**
     * Resolves an address autocompletion by its address ID.
     *
     * Resolved addresses (including global addresses) are returned in a UK format (up to 3 address lines) using UK nomenclature (like postcode and county).
     */
    get: operations["Resolve"];
  };
  "/autocomplete/addresses/{address}/usa": {
    /**
     * Resolves an address autocompletion by its address ID.
     *
     * Resolved addresses (including global addresses) are returned in a US format (up to 2 address lines) using US nomenclature (like zipcode, state and city).
     */
    get: operations["ResolveUsa"];
  };
  "/addresses": {
    /**
     * Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
     *
     * If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
     *
     * This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
     *
     * For address autocomplete, see our address finder API - which is designed for speed and address completion.
     *
     * ## Reverse Geocoding
     *
     * Return a list of addresses around a point using the lon= and lat= querystring arguments. Addresses will be sorted in order of distance to the point. The search radius is 100m.
     *
     * ## Filters
     *
     * You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
     *
     * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
     *
     * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
     *
     * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
     *
     * All filters can accept multiple terms unless stated otherwise below.
     *
     * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
     *
     * A combined maximum of 5 terms are allowed across all filters.
     *
     * ## Biases
     *
     * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
     *
     * Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
     *
     * For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
     *
     * If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
     *
     * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
     *
     * All biases can accept multiple terms unless stated otherwise below.
     *
     * A combined maximum of 5 terms are allowed across all biases.
     *
     * ## Search by Postcode and Building Name or Number
     *
     * Search by postcode and building attribute with the postcode filter and query argument. E.g. For "SW1A 2AA Prime Minister" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
     *
     * The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
     *
     * #### Search By UPRN
     *
     * Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
     *
     * ## Testing
     *
     * - **ID1 1QD** Returns a successful query response `2000`
     * - **ID1 KFA** Returns an empty query response `2000`
     * - **ID1 CLIP** Returns "no lookups remaining" error `4020`
     * - **ID1 CHOP** Returns "daily (or individual) lookup limit breached" error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["Addresses"];
  };
  "/keys/{key}/licensees": {
    /** Returns a list of licensees for a key. */
    get: operations["ListLicensees"];
    /** Create a licensee for the specified API Key. */
    post: operations["CreateLicensee"];
  };
  "/keys/{key}/licensees/{licensee}": {
    /** Returns licensee information as identified by the licensee key. */
    get: operations["RetrieveLicensee"];
    /** Update Licensee */
    put: operations["UpdateLicensee"];
    /** Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us. */
    delete: operations["DeleteLicensee"];
  };
  "/keys/{key}/configs": {
    /** Lists configurations associated with a key */
    get: operations["ListConfigs"];
    /** Create a config */
    post: operations["CreateConfig"];
  };
  "/keys/{key}/configs/{config}": {
    /** Retrieve config object by name */
    get: operations["RetrieveConfig"];
    /** Updates configuration object */
    post: operations["UpdateConfig"];
    /** Permanently deletes a configuration object. */
    delete: operations["DeleteConfig"];
  };
}

export interface components {
  schemas: {
    ecaf: components["schemas"]["EcafAddress"];
    ecad: components["schemas"]["EcadAddress"];
    /**
     * Postcode
     * @description Correctly formatted postcode. Capitalised and spaced.
     * @example SW1A 2AA
     */
    paf_postcode: string;
    /**
     * API Key
     * @description Your API Key. Typically beings `ak_`.
     *
     * Available from your dashboard
     *
     * @example ak_hk71kco54zGSGvF9eXXrvvnMOLLNh
     */
    ApiKeyParam: string;
    /**
     * Filter
     * @description Comma separated whitelist of address elements to return.
     *
     * E.g. `filter=line_1,line_2,line_3` returns only `line_1`, `line_2` and `line_3` address elements in your response
     *
     * @example line_1,line_2,line_3
     */
    FilterParam: string;
    /**
     * Page
     * Format: int32
     * @description 0 indexed indicator of the page of results to receive. Virtually all postcode results are returned on page 0.
     *
     * A small number of Multiple Residence postcodes may need pagination (i.e. have more than 100 premises).
     */
    PageParam: number;
    /**
     * ID
     * @description Global unique internally generated identifier for an address
     * @example paf_8387729
     */
    ID: string;
    /**
     * Dataset
     * @description Indicates the provenance of an address
     */
    paf_dataset: string;
    /**
     * ISO Country Code (3)
     * @description   3 letter country code (ISO 3166-1)
     */
    paf_country_iso: string;
    /**
     * ISO Country Code (2)
     * @description  2 letter country code (ISO 3166-1)
     */
    paf_country_iso_2: string;
    /**
     * Country
     * @description   Full country names (ISO 3166)
     *
     * @example England
     */
    paf_country: string;
    /**
     * Language
     * @description Language represented by 2 letter ISO Code (639-1)
     */
    paf_language: string;
    /**
     * Line 1
     * @description First Address Line. Often contains premise and thoroughfare information. In the case of a commercial premise, the first line is always the full name of the registered organisation. Never empty.
     * @example Prime Minister &amp; First Lord of Treasury
     */
    paf_line1: string;
    /**
     * Line 2
     * @description Second Address Line. Often contains thoroughfare and locality information. May be empty
     * @example 10 Downing Street
     */
    paf_line2: string;
    /**
     * Line 3
     * @description Third address line. May be empty.
     */
    paf_line3: string;
    /**
     * Post Town
     * @description A Post Town is mandatory for delivery of mail to a Delivery Point. This is not necessarily the nearest town geographically, but a routing instruction to the Royal Mail delivery office sorting mail for that Delivery Point. A Post Town will always be present in every address, and for some Localities the Post Town will be the only locality element present.
     * @example London
     */
    paf_post_town: string;
    /**
     * County
     * @description Since postal, administrative or traditional counties may not apply to some addresses, the county field is designed to return whatever county data is available. Normally, the postal county is returned. If this is not present, the county field will fall back to the administrative county. If the administrative county is also not present, the county field will fall back to the traditional county. May be empty in cases where no administrative, postal or traditional county present.
     * @example London
     */
    paf_county: string;
    /**
     * Unique Property Reference Number
     * @description UPRN stands for Unique Property Reference Number and is maintained by the Ordnance Survey (OS). Local governments in the UK have allocated a unique number for each land or property.
     *
     * Up to 12 digits in length.
     *
     * Multiple Residence premises currently share the same UPRN as the parent premise.
     *
     * May not be available for a small number of Great Britain addresses due to longer update cycles for Ordnance Survey's AddressBase datasets. Returns empty string "" in these instances.
     *
     * Although UPRN takes an integer format, we encode and transmit this data as strings. As a 12 digit number, the UPRN can exceed the maximum safe integer `Number.MAX_SAFE_INTEGER` in most browsers causing this datapoint to be corrupted.
     *
     * Take special care when storing UPRN. As a 12 digit identifier, you will need 64 bits to encode every possible UPRN value. This means applications like Excel will corrupt cells containing UPRN values.
     */
    paf_uprn: string;
    /**
     * Unique Delivery Point Reference Number (UDPRN)
     * Format: int32
     * @description UDPRN stands for ‘Unique Delivery Point Reference Number’. Royal Mail assigns a unique UDPRN code for each premise on PAF. Simple, unique reference number for each Delivery Point. Unlikely to be reused when an address expires.
     *
     * Up to 8-digit numeric code.
     *
     * A new UDPRN is automatically assigned to each new Delivery Point added to PAF.
     * @example 23747771
     */
    paf_udprn: number;
    /**
     * UMPRN
     * @description A small minority of individual premises (as identified by a UDPRN) may have multiple occupants behind the same letterbox. These are known as Multiple Residence occupants and can be queried via the Multiple Residence dataset. Simple, unique reference number for each Multiple Residence occupant.
     *
     * Note: this will be an empty string `""` when not used.
     */
    paf_umprn: string | number;
    /**
     * Postcode Outward
     * @description The first part of a postcode is known as the outward code. e.g. The outward code of ID1 1QD is ID1. Enables mail to be sorted to the correct local area for delivery. This part of the code contains the area and the district to which the mail is to be delivered, e.g. ‘PO1’, ‘SW1A’ or ‘B23’.
     * @example SW1A
     */
    paf_postcode_outward: string;
    /**
     * Postcode Inward
     * @description The second part of a postcode is known as the inward code. e.g. The inward code of ID1 1QD is 1QD.
     *
     * The number identifies the sector in the postal district. The number is followed by 2 letters. The letters then define one or more properties in that sector.
     * @example 2AA
     */
    paf_postcode_inward: string;
    /**
     * Dependant Locality
     * @description When the same thoroughfare name reoccurs in a Post town, it may not be possible to make it dependant on a dependant thoroughfare. In this case the thoroughfare is dependant on a locality. For example if we want to find 1 Back Lane in Huddersfield we see that there are three.
     */
    paf_dependant_locality: string;
    /**
     * Double Dependant Locality
     * @description Used to supplement Dependant Locality. A Double Dependant Locality supplied along with a Dependant Locality if the Dependant Locality exists twice in the same locality.
     */
    paf_double_dependant_locality: string;
    /**
     * Thoroughfare
     * @description Also known as the street or road name. In general each Thoroughfare Name will have a separate Postcode. Longer Thoroughfares with high number ranges often have multiple Postcodes covering the entire length of the road, with breaks at suitable points e.g. junctions or natural breaks in the road.
     * @example Downing Street
     */
    paf_thoroughfare: string;
    /**
     * Dependant Thoroughfare
     * @description Used to supplement thoroughfare. When a thoroughfare name is used twice in the same Post Town, the dependant thoroughfare is added to uniquely indentify a delivery point.
     */
    paf_dependant_thoroughfare: string;
    /**
     * Building Number
     * @description Number to identify premise on a thoroughfare or dependant thoroughfare.
     * @example 10
     */
    paf_building_number: string;
    /**
     * Building Name
     * @description Name of residential or commercial premise.
     *
     * Examples:
     *   - The Manor
     *   - 1-2
     *   - A
     *   - 12A
     *   - K
     *   - Victoria House
     */
    paf_building_name: string;
    /**
     * Sub-Building Name
     * @description When a premise is split into individual units such as flats, apartments or business units. Cannot be present without either building_name or building_number. E.g. Flat 1, A, 10B
     * @example Flat 1
     */
    paf_sub_building_name: string;
    /**
     * PO Box
     * @description When the PO Box Number field is populated it will contain PO BOX nnnnnn where n represents the PO Box number. Note that the PO Box details can occasionally consist of a combination of numbers and letters. PO Box Numbers are only allocated to Large Users.
     * @example 100
     */
    paf_pobox: string;
    /**
     * Department Name
     * @description Used to supplment Organisation Name to identify a deparment within the organisation.
     */
    paf_department_name: string;
    /**
     * Organisation Name
     * @description Used to supplment Organisation Name to identify a deparment within the organisation
     * @example Prime Minister &amp; First Lord Of The Treasury
     */
    paf_organisation_name: string;
    /**
     * Postcode Type
     * @description This indicates the type of user. It can only take the values 'S' or 'L' indicating small or large respectively. Large User Postcodes. These are assigned to one single address either due to the large volume of mail received at that address, or because a PO Box or Selectapost service has been set up. Small User Postcodes. These identify a group of Delivery Points.
     *
     * On average there are 15 Delivery Points per Postcode. However this can vary between 1 and, in some cases, 100. There will never be more than 100 Delivery Points on a Postcode.
     * @enum {string}
     */
    paf_postcode_type: "S" | "L";
    /**
     * Small User Organisation Indicator
     * @description Small User Organisation Indicator can have the values 'Y' or space. A value of 'Y' indicates that a Small User Organisation is present at this address.
     * @example Y
     */
    paf_su_organisation_indicator: string;
    /**
     * Delivery Point Suffix
     * @description A unique Royal Mail 2-character code (the first numeric & the second alphabetical), which, when added to the Postcode, enables each live Delivery Point to be uniquely identified. Once the Delivery Point is deleted from PAF the DPS may be reused (although they aren’t reused until all remaining Delivery Points in the range have been allocated). The DPS for a Large User is always '1A' as each Large User has its own Postcode.
     * @example 1A
     */
    paf_delivery_point_suffix: string;
    /**
     * Premise
     * @description A pre-computed string which sensibly combines building_number, building_name and sub_building_name. building_number, building_name and sub_building_name represent raw data from Royal Mail's and can be difficult to parse if you are unaware of how the Postcode Address File premise fields work together. For this reason, we also provide a pre-computed premise field which intelligently gathers these points into a single, simple premise string. This field is ideal if you want to pull premise information and thoroughfare information separately instead of using our address lines data.
     * @example 10
     */
    paf_premise: string;
    /**
     * Administrative County
     * @description The current administrative county to which the postcode has been assigned.
     *
     * A Unitary Authority name, where one is present. If there is no Unitary Authority, the County name is used. This information is not static, because County boundaries may change due to administrative changes. Data
     *
     * source: ONS
     */
    paf_administrative_county: string;
    /**
     * Postal County
     * @description Postal counties were used for the distribution of mail before the Postcode system was introduced in the 1970s. The Former Postal County was the Administrative County at the time. This data rarely changes. May be empty.
     * @example London
     */
    paf_postal_county: string;
    /**
     * Traditional County
     * @description Traditional counties are provided by the Association of British Counties. It is historical data, and can date from the 1800s. May be empty.
     * @example Greater London
     */
    paf_traditional_county: string;
    /**
     * District
     * @description The current district/unitary authority to which the postcode has been assigned.
     * @example Westminster
     */
    paf_district: string;
    /**
     * Ward
     * @description The current administrative/electoral area to which the postcode has been assigned. May be empty for a small number of addresses.
     * @example St. James'
     */
    paf_ward: string;
    /**
     * Longitude
     * @description The longitude of the postcode (WGS84/ETRS89).
     *
     * Can be a positive or negative decimal. E.g. -0.1283983
     *
     * Returns an empty string if no location data is available.
     */
    Longitude: string | number;
    /**
     * Longitude
     * @description The latitude of the postcode (WGS84/ETRS89).
     *
     * Can be a positive or negative decimal. E.g. `51.5083983`.
     *
     * Returns an empty string if no location data is available.
     */
    Latitude: string | number;
    /**
     * Eastings
     * @description Eastings reference using the [Ordnance Survey National Grid reference system](https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid).
     *
     * Northern Ireland Eastings uses the [Irish Grid Reference System](https://en.wikipedia.org/wiki/Irish_grid_reference_system).
     *
     * Metres from origin. E.g. `550458`
     *
     * Returns an empty string if no location data is available. Otherwise a number is returned.
     */
    Eastings: string | number;
    /**
     * Northings
     * @description Northings reference using the [Ordnance Survey National Grid reference system](https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid)
     *
     * Northern Ireland Northings uses the [Irish Grid Reference System](https://en.wikipedia.org/wiki/Irish_grid_reference_system)
     *
     * Metres from origin. E.g. `180458`
     *
     * Returns an empty string if no location data is available. Otherwise a number is returned
     */
    Northings: string | number;
    PafBase: {
      id: components["schemas"]["ID"];
      dataset: components["schemas"]["paf_dataset"];
      country_iso: components["schemas"]["paf_country_iso"];
      country_iso_2: components["schemas"]["paf_country_iso_2"];
      country: components["schemas"]["paf_country"];
      language: components["schemas"]["paf_language"];
      line_1: components["schemas"]["paf_line1"];
      line_2: components["schemas"]["paf_line2"];
      line_3: components["schemas"]["paf_line3"];
      post_town: components["schemas"]["paf_post_town"];
      postcode: components["schemas"]["paf_postcode"];
      county: components["schemas"]["paf_county"];
      /**
       * County Code
       * @description Short code representing the county or province. May be empty (`""`)
       */
      county_code: string;
      uprn: components["schemas"]["paf_uprn"];
      udprn: components["schemas"]["paf_udprn"];
      umprn: components["schemas"]["paf_umprn"];
      postcode_outward: components["schemas"]["paf_postcode_outward"];
      postcode_inward: components["schemas"]["paf_postcode_inward"];
      dependant_locality: components["schemas"]["paf_dependant_locality"];
      double_dependant_locality: components["schemas"]["paf_double_dependant_locality"];
      thoroughfare: components["schemas"]["paf_thoroughfare"];
      dependant_thoroughfare: components["schemas"]["paf_dependant_thoroughfare"];
      building_number: components["schemas"]["paf_building_number"];
      building_name: components["schemas"]["paf_building_name"];
      sub_building_name: components["schemas"]["paf_sub_building_name"];
      po_box: components["schemas"]["paf_pobox"];
      department_name: components["schemas"]["paf_department_name"];
      organisation_name: components["schemas"]["paf_organisation_name"];
      postcode_type: components["schemas"]["paf_postcode_type"];
      su_organisation_indicator: components["schemas"]["paf_su_organisation_indicator"];
      delivery_point_suffix: components["schemas"]["paf_delivery_point_suffix"];
      premise: components["schemas"]["paf_premise"];
      administrative_county: components["schemas"]["paf_administrative_county"];
      postal_county: components["schemas"]["paf_postal_county"];
      traditional_county: components["schemas"]["paf_traditional_county"];
      district: components["schemas"]["paf_district"];
      ward: components["schemas"]["paf_ward"];
      longitude: components["schemas"]["Longitude"];
      latitude: components["schemas"]["Latitude"];
      eastings: components["schemas"]["Eastings"];
      northings: components["schemas"]["Northings"];
    };
    /**
     * Postcode Address File Address
     * @description Standard UK Address. Also known as a Postcode Address File (PAF) address is defined by Royal Mail and updated on a daily cadence.
     *
     * A PAF Address represents a deliverable endpoint.
     */
    PafAddress: components["schemas"]["PafBase"] & {
      /** @enum {undefined} */
      country_iso?: "GBR" | "IMN" | "JEY" | "GGY";
      /** @enum {string} */
      dataset?: "paf";
      /** @enum {undefined} */
      country_iso_2?: "GB" | "IM" | "JE" | "GG";
      /** @enum {undefined} */
      language?: "en";
      /** @enum {undefined} */
      country?:
        | "England"
        | "Scotland"
        | "Wales"
        | "Northern Ireland"
        | "Jersey"
        | "Guernsey"
        | "Isle of Man";
    };
    /**
     * Multiple Residence Address
     * @description Subdivision of a Postcode Address File address. Also known as a Multiple Residence or Multiple Occupancy address.
     *
     * A Multiple Residence address does not have its own deliverable endpoint. Instead it relies on the deliverable endpoint of a parent address, where the parent address can be found on the main Postcode Address File.
     */
    MrAddress: components["schemas"]["PafBase"] & {
      /** @enum {undefined} */
      dataset?: "mr";
      /** @enum {undefined} */
      country_iso?: "GBR" | "IMN" | "JEY" | "GGY";
      /** @enum {undefined} */
      country_iso_2?: "GB" | "IM" | "JE" | "GG";
      /** @enum {undefined} */
      language?: "en";
      /** @enum {undefined} */
      country?:
        | "England"
        | "Scotland"
        | "Wales"
        | "Northern Ireland"
        | "Jersey"
        | "Guernsey"
        | "Isle of Man";
    };
    /**
     * Not Yet Built Address
     * @description A UK premise under construction and currently not occupied.
     *
     * This dataset is updated by Royal Mail on a monthly cadence.
     */
    NybAddress: components["schemas"]["PafBase"] & {
      /** @enum {undefined} */
      dataset?: "nyb";
      /** @enum {undefined} */
      country_iso?: "GBR" | "IMN" | "JEY" | "GGY";
      /** @enum {undefined} */
      country_iso_2?: "GB" | "IM" | "JE" | "GG";
      /** @enum {undefined} */
      language?: "en";
      /** @enum {undefined} */
      country?:
        | "England"
        | "Scotland"
        | "Wales"
        | "Northern Ireland"
        | "Jersey"
        | "Guernsey"
        | "Isle of Man";
    };
    /**
     * PAF Alias Address
     * @description PAF Aliases addresses are alternate ways to present an address already found on PAF.
     *
     * Alias data is information the public chooses to use when addressing mail, but which isn’t actually required for delivery purposes.  The Alias data contains records of alternative address details that are included in the address but not necessarily needed for delivery purposes.
     */
    PafAliasAddress: components["schemas"]["PafBase"] & {
      /** @enum {undefined} */
      dataset?: "pafa";
      /** @enum {undefined} */
      country_iso?: "GBR" | "IMN" | "JEY" | "GGY";
      /** @enum {undefined} */
      country_iso_2?: "GB" | "IM" | "JE" | "GG";
      /** @enum {undefined} */
      language?: "en";
      /** @enum {undefined} */
      country?:
        | "England"
        | "Scotland"
        | "Wales"
        | "Northern Ireland"
        | "Jersey"
        | "Guernsey"
        | "Isle of Man";
    };
    /**
     * Welsh PAF Address
     * @description Welsh language alternative for a PAF Address
     */
    WelshPafAddress: components["schemas"]["PafBase"] & {
      /** @enum {undefined} */
      dataset?: "pafw";
      /** @enum {undefined} */
      country_iso?: "GBR";
      /** @enum {undefined} */
      country_iso_2?: "GB";
      /** @enum {undefined} */
      language?: "cy";
      /** @enum {undefined} */
      country?: "Wales";
    };
    /** Postcode Response */
    PostcodeResponse: {
      /** @description All addresses listed at the postcode */
      result: (
        | components["schemas"]["PafAddress"]
        | components["schemas"]["MrAddress"]
        | components["schemas"]["NybAddress"]
        | components["schemas"]["PafAliasAddress"]
        | components["schemas"]["WelshPafAddress"]
      )[];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** Basic Error Response */
    ErrorResponse: {
      /**
       * Format: int32
       * @description API Response Code. Non `2xxx` code indicates a failure. This code will provide a more specific reason when a failure occurs and facilitates debugging.
       */
      code: number;
      /** @description Human readable error message supplied with every error response. */
      message: string;
    };
    /** Bad Request Error Response */
    BadRequestResponse: components["schemas"]["ErrorResponse"] & {
      /**
       * Format: int32
       * @description `400X` type error response code
       */
      code: number;
      /** @description Bad request error description */
      message: string;
      errors?: {
        /**
         * @description Indicates location of error in request query or URL parameter
         * @example should have required property 'type'
         */
        message: string;
        /**
         * @description Indicates location of error in request query or URL parameter
         * @example .query.type
         */
        path: string;
        /** @example required.openapi.validation */
        errorCode?: string;
      }[];
    };
    /** Postcode Not Found */
    PostcodeNotFoundResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 4040;
      /** @enum {string} */
      message: "Postcode not found";
      /** @description A list of alternate nearest matching postcodes you can try */
      suggestions: string[];
    };
    /** UDPRN Response */
    UDPRNResponse: {
      result:
        | components["schemas"]["PafAddress"]
        | components["schemas"]["NybAddress"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** UDPRN Response */
    UMPRNResponse: {
      result: components["schemas"]["MrAddress"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Available Contexts
     * @description A list of available contexts for a key
     */
    AvailableContexts: {
      /**
       * @description 3 letter ISO code
       * @example USA
       */
      iso_3?: string;
      /**
       * @description 2 letter ISO code
       * @example US
       */
      iso_2?: string;
      /**
       * @description Country descriptor to show in Address Finder
       *
       * @example United States
       */
      description?: string;
      /**
       * @description Emoji text icon
       * @example 🇺🇸
       */
      emoji?: string;
      /**
       * @description Indicates availability of reverse geolocation search
       *
       * @example true
       */
      rgeo?: boolean;
    }[];
    /**
     * Context
     * @description Limits search results within a geographical boundary or country.
     */
    Context: string;
    /**
     * No Context Provided
     * @description Empty string if no context is provided or key check has failed
     * @enum {string}
     */
    NoContext: "";
    /** Key */
    ApiKey: {
      contexts: components["schemas"]["AvailableContexts"];
      /** @description Returns current context if it is in the list of available contexts for this key. */
      context:
        | components["schemas"]["Context"]
        | components["schemas"]["NoContext"];
      /**
       * @description Determines whether the key can be used by the requesting agent.
       *
       * Returns false if one of the following conditions are met:
       *   - Key has no lookups remaining
       *   - Daily limit has been reached on the key
       *   - Daily individual limit has been reached
       *   - Key is not being used via an authorised URL
       *   - (Sublicensed key only) Key has a valid licensee attached
       *   - (Sublicensed key only) Key is not being used via an authorised URL specified by licensee
       *
       * @example true
       */
      available: boolean;
    };
    /** API Key Response */
    ApiKeyResponse: {
      result: components["schemas"]["ApiKey"];
      /** @enum {string} */
      message: "Success";
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
    };
    /**
     * User Token
     * @description A secret key used for sensitive operations on your account and API Keys.
     *
     * Your user token can be retrieved and managed from your [accounts page](https://ideal-postcodes.co.uk/account).
     *
     * Typically beings `uk_...`
     *
     * @example uk_B59ScW1p1HHouf1VqclEPZUx
     */
    UserTokenParam: string;
    /** API Key Daily Limit */
    ApiKeyDailyLimit: {
      /**
       * Format: int32
       * @description `number` or `null`. The daily lookup limit currently set on your key.
       * `null` means the limit is currently disabled.
       * @example 1000
       */
      limit: number;
      /**
       * Format: int32
       * @description Number of lookups performed today which count towards your daily limit.
       * @example 288
       */
      consumed: number;
    };
    /** API Key Individual Limit */
    ApiKeyIndividualLimit: {
      /**
       * Format: int32
       * @description `number` or `null` Limit set on the number of lookups that can be
       * performed from a single IP address. `null` means the limit is currently
       * disabled.
       * @example 30
       */
      limit: number;
    };
    /** API Key Notifications */
    ApiKeyNotifications: {
      /** @description A list of email addresses designated by you to receive notifications about this key. */
      emails: string[];
      /** @description Indicates whether email notifications are enabled. */
      enabled: boolean;
    };
    /**
     * API Key Dataset Availability
     * @description Indicates which datasets are available and added by default to the address responses
     */
    ApiKeyDatasets: {
      /**
       * @description UK Postcode Address File enabled
       * @example true
       */
      paf: boolean;
      /**
       * @description UK Multiple Residence Dataset enabled
       * @example true
       */
      mr: boolean;
      /** @description UK Not Yet Built Dataset enabled */
      nyb: boolean;
    };
    /**
     * API Key Automated Topup
     * @description Automated topup status
     */
    ApiKeyAutomatedTopup: {
      /**
       * @description Indicates whether automated top-ups are enabled
       * @example true
       */
      enabled: boolean;
    };
    /** API Key Batch Purchase */
    ApiKeyCurrentPurchase: {
      /**
       * @description `string` or `null` The date when this purchase will expire in simplified
       * extended ISO format (ISO 8601). This is typically 365 days from the time
       * of first use. This field will be `null` if the purchase has not yet been
       * used.
       * @example 2022-01-06T11:41:27.092Z
       */
      expires: string;
      /**
       * Format: int32
       * @description Number of procured lookups from this purchase.
       * @example 20000
       */
      purchased: number;
      /**
       * Format: int32
       * @description Number of consumed lookups off this purchase.
       * @example 121
       */
      consumed: number;
    };
    /** API Key Details */
    ApiKeyDetails: {
      /**
       * Format: int32
       * @example 19889
       */
      lookups_remaining: number;
      daily_limit: components["schemas"]["ApiKeyDailyLimit"];
      individual_limit: components["schemas"]["ApiKeyIndividualLimit"];
      /** @description A list of allowed URLs. An empty list means that allowed URLs are disabled. */
      allowed_urls: string[];
      notifications?: components["schemas"]["ApiKeyNotifications"];
      datasets?: components["schemas"]["ApiKeyDatasets"];
      automated_topups: components["schemas"]["ApiKeyAutomatedTopup"];
      /** @description Current balance purchases attached to key. */
      current_purchases: components["schemas"]["ApiKeyCurrentPurchase"][];
    } & {
      notificatinos: unknown;
    };
    /** API Key Details Response */
    ApiKeyDetailsResponse: {
      result: components["schemas"]["ApiKeyDetails"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Start Time
     * Format: int32
     * @description A start date/time in the form of a UNIX Timestamp in milliseconds, e.g.  `1418556452651`.
     *
     * @example 1418556452651
     */
    StartParam: number;
    /**
     * End Time
     * Format: int32
     * @description An start date/time in the form of a UNIX Timestamp in milliseconds, e.g.  `1418556477882`.
     *
     * @example 1418556477882
     */
    EndParam: number;
    /**
     * Tags
     * @description A comma separated list of tags to query over.
     *
     * Useful if you want to specify the circumstances in which the request was made.
     *
     * If multiple tags are specified, the response will only comprise of requests for which all the tags are satisfied - i.e. searching `"foo,bar"` will only query requests which tagged both `"foo"` and `"bar"`.
     *
     * @example foo,bar
     */
    TagsParam: string;
    /**
     * Licensee Key
     * @description Uniquely identifies a licensee
     *
     * @example sk_hk71kco54zGSGvF9eXXrvvnMOLLNh
     */
    LicenseeParam: string;
    /** Key Usage */
    KeyUsageResult: {
      /**
       * @description Start date in ISO 8601 format.
       * @example 2015-01-22T15:08:06.609Z
       */
      start: string;
      /**
       * @description End date in ISO 8601 format.
       * @example 2015-01-23T15:08:06.609Z
       */
      end: string;
      /**
       * Format: int32
       * @description Total of paid lookups performed in specified period.
       * @example 132
       */
      total: number;
      /** @description An array of objects representing number of paid lookups made on specific days, ordered by date. Each object contains a `date` attribute, which represents the day and a `count` attribute, which represents the number of paid lookups made on that day. */
      dailyCount: {
        /** @example 2015-01-22T00:00:00.000Z */
        date: string;
        /**
         * Format: int32
         * @example 132
         */
        count: number;
      }[];
    };
    /** Key Usage Response */
    ApiKeyUsageResponse: {
      result: components["schemas"]["KeyUsageResult"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Limit
     * Format: int32
     * @description Specifies the maximum number of suggestions to retrieve.
     *
     * By default the limit is 10, unless a postcode is queried (then all addresses at that postcode will be returned). Limit can be shortened to `l=`
     *
     * @default 10
     * @example 5
     */
    LimitParam: number;
    /**
     * Postcode Outward
     * @description Filter by outward code.
     * @example 1AA
     */
    PostcodeOutwardParam: string;
    /**
     * Postcode
     * @description Filter by postcode. Can be combined with query to perform a postcode + building number/name search.
     * @example SW1A 2AA
     */
    PostcodeParam: string;
    /**
     * Postcode Area
     * @description Filter by postcode. Can be combined with query to perform a postcode + building number/name search.
     * @example SW
     */
    PostcodeAreaParam: string;
    /**
     * Postcode Sector
     * @description Filter by postcode sector, the outward code plus first numeric of the inward code.
     * @example SW1A 2
     */
    PostcodeSectorParam: string;
    /**
     * Post Town
     * @description Filter by town.
     * @example London
     */
    PostTownParam: string;
    /**
     * UPRN
     * @description Filters by UPRN. Does not accept comma separated terms. Only a single term is permitted
     * @example 100023336956
     */
    UPRNParam: number;
    /**
     * Country
     * @description Filter by country. Possible values are England, Scotland, Wales, Northern Ireland, Jersey, Guernsey and Isle of Man.
     * @example England
     */
    CountryParam: string;
    /**
     * Country
     * @description Filter by Postcode Type. Useful for separating organisational and residential addresses
     * @example L
     */
    PostcodeTypeParam: string;
    /**
     * SU Organisation Indicator
     * @description Filter by Organisation Indicator. Useful for separating organisational and residential addresses
     * @example Y
     */
    SmallUserParam: string;
    /**
     * Box
     * @description Restrict search to a geospatial box determined by the "top-left" and "bottom-right" gelocations.   Only one geospatial box can be provided.
     * @example 2.095,57.15,-2.096,57.14
     */
    BoxParam: string;
    /**
     * Bias Postcode Outward
     * @description Bias by outward code
     */
    BiasPostcodeOutwardParam: string;
    /**
     * Bias Postcode
     * @description Bias by postcode. Can be combined with query to perform a postcode + building number/name search.
     * @example /addresses?postcode=SW1A2AA&q=10
     */
    BiasPostcodeParam: string;
    /**
     * Bias Postcode Area
     * @description Bias by postcode area, the first one or two non-numeric characters of a postcode.
     * @example The postcode area of SW1A 2AA and N1 6RT are SW and N respectively
     */
    BiasPostcodeAreaParam: string;
    /**
     * Bias Postcode Sector
     * @description Bias by postcode sector, the outward code plus first numeric of the inward code.
     * @example SW1A 2AA is SW1A 2
     */
    BiasPostcodeSectorParam: string;
    /**
     * Bias Post Town
     * @description Bias by town.
     */
    BiasPosttownParam: string;
    /**
     * Bias Thoroughfare
     * @description Bias by street name.
     */
    BiasThoroughfareParam: string;
    /**
     * Bias County
     * @description Bias by country. Possible values are England, Scotland, Wales, Northern Ireland, Jersey, Guernsey and Isle of Man.
     */
    BiasCountryParam: string;
    /**
     * Bias Lon/Lat
     * @description Bias search to a geospatial circle determined by an origin and radius in meters. Max radius is `50000`.  Uses the format bias_lonlat=[longitude],[latitude],[radius in metres] Only one geospatial bias may be provided
     * @example -2.095,57.15,100
     */
    BiasLonLatParam: string;
    /**
     * Bias query by Geolocation of IP
     * @description Biases search based on approximate geolocation of IP address.
     * Set `bias_ip=true` to enable.
     * @example bias_ip=true
     * @enum {string}
     */
    BiasIpParam: "true";
    /**
     * Address Suggestion
     * @description Represents an address suggestion for any address in the world
     */
    AddressSuggestion: {
      id: components["schemas"]["ID"];
      /**
       * @description Address Suggestion to be displayed to the user
       * @example Flat 6, 12 Roskear, Camborne, TR14
       */
      suggestion: string;
      urls: { [key: string]: unknown };
    };
    /**
     * UK Address Suggestion
     * @description Represents a possible address given an autocomplete query.
     *
     * UK Address Suggestions will return a UDPRN attribute if it references a deliverable endpoint found on Royal Mail's Postcode Address File dataset.
     *
     * UK Address Suggestion will return a UMPRN if it references a multiple occupancy premise found on Royal Mail's Multiple Residence dataset.
     */
    UkAddressSuggestion: {
      id: components["schemas"]["ID"];
      /**
       * @description Address suggestion for a given query.
       * @example Flat 6, 12 Roskear, Camborne, TR14
       */
      suggestion: string;
      udprn: components["schemas"]["paf_udprn"];
      /**
       * Format: int32
       * @description Optionally returned field, representing the UMPRN of a Multiple Residence household
       * @example 51103417
       */
      umprn?: number;
      urls: {
        /**
         * @description URL to retrieve the entire details for a given address suggestion by the UDPRN
         * @example /v1/udprn/50985827
         */
        udprn: string;
        /**
         * @description Optionally returned field, to retrieve the entire details for a suggested Multiple Residence household
         * @example /v1/umprn/51103417
         */
        umprn?: string;
      };
    };
    /** Address Autocomplete Response */
    AutocompleteResponse: {
      result: {
        hits: (
          | components["schemas"]["AddressSuggestion"]
          | components["schemas"]["UkAddressSuggestion"]
        )[];
      };
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Dataset
     * @description Indicates the provenance of an address.
     *
     *   - `paf` (GBR) Postcode Address File
     *   - `mr` (GBR) Multiple Residence File
     *   - `nyb` (GBR) Not Yet Built File
     *   - `pafa` (GBR) Alias File
     *   - `pafw` (GBR) Welsh File
     *   - `ecaf` (IRL) Eircode ECAF
     *   - `ecad` (IRL) Eircode ECAD
     *   - `usps` (USA) USPS Zip+4
     * @enum {string}
     */
    Dataset: "paf" | "pafw" | "pafa" | "mr" | "nyb" | "usps" | "ecaf" | "ecad";
    /**
     * ISO Country Code (3)
     * @description   3 letter country code (ISO 3166-1)
     *
     * @enum {string}
     */
    CountryISO: "GBR" | "IMN" | "JEY" | "GGY" | "USA" | "PRI" | "GUM" | "IRL";
    /**
     * ISO Country Code (2)
     * @description  2 letter country code (ISO 3166-1)
     *
     * @enum {string}
     */
    CountryISO2: "GB" | "IM" | "JE" | "GG" | "US" | "PR" | "GU" | "IE";
    /**
     * Language
     * @description Language represented by 2 letter ISO Code (639-1)
     *
     * @enum {string}
     */
    Language: "en" | "cy" | "ga";
    /**
     * Country
     * @description   Full country names (ISO 3166)
     *
     * @example England
     * @enum {string}
     */
    Country:
      | "United States"
      | "Guam"
      | "Puerto Rico"
      | "England"
      | "Scotland"
      | "Wales"
      | "Northern Ireland"
      | "Jersey"
      | "Guernsey"
      | "Isle of Man"
      | "Ireland";
    /**
     * Global Address
     * @description Global (non-UK) address in the UK address format
     */
    GbrGlobalAddress: {
      id: components["schemas"]["ID"];
      dataset: components["schemas"]["Dataset"];
      country_iso: components["schemas"]["CountryISO"];
      country_iso_2: components["schemas"]["CountryISO2"];
      language: components["schemas"]["Language"];
      /** @description First address line */
      line_1: string;
      /** @description Second address line */
      line_2: string;
      /** @description Third address line */
      line_3: string;
      /** @description Postal Code or Zip Code */
      postcode: string;
      /** @description Town or City */
      post_town: string;
      /** @description Province, state or county */
      county: string;
      /**
       * @description Code or abbreviation associated with provice, state or county
       * @example NY
       */
      county_code: string;
      longitude: components["schemas"]["Longitude"];
      latitude: components["schemas"]["Latitude"];
      country: components["schemas"]["Country"];
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postcode_outward: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postcode_inward: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      dependant_locality: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      double_dependant_locality: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      thoroughfare: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      dependant_thoroughfare: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      building_number: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      building_name: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      sub_building_name: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      premise: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      po_box: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      department_name: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      organisation_name: "";
      /**
       * @description Not available for non-UK addresses. See `id` for address identifier
       * @enum {string}
       */
      udprn: "";
      /**
       * @description Not available for non-UK addresses. See `id` for address identifier
       * @enum {string}
       */
      umprn: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postcode_type: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      su_organisation_indicator: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      delivery_point_suffix: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      administrative_county: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postal_county: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      traditional_county: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      district: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      ward: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      eastings: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      northings: "";
      /**
       * @description Not available for non-UK addresses. See `id` for address identifier
       * @enum {string}
       */
      uprn: "";
    };
    /** Address Resolution Response (GBR) */
    GbrResolveAddressResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
      result:
        | components["schemas"]["PafAddress"]
        | components["schemas"]["MrAddress"]
        | components["schemas"]["WelshPafAddress"]
        | components["schemas"]["PafAliasAddress"]
        | components["schemas"]["NybAddress"]
        | components["schemas"]["GbrGlobalAddress"];
    };
    /**
     * USA Dataset
     * @description Identifies the address as sourced from USPS
     * @enum {string}
     */
    usps_dataset: "usps";
    /**
     * Country
     * @description   Full country names (ISO 3166)
     *
     * @enum {string}
     */
    usps_country: "United States" | "Guam" | "Puerto Rico";
    /**
     * ISO Country Code (3)
     * @description   3 letter country code (ISO 3166-1)
     *
     * @enum {string}
     */
    usps_country_iso: "USA" | "PRI" | "GUM";
    /**
     * ISO Country Code (2)
     * @description  2 letter country code (ISO 3166-1)
     *
     * @enum {string}
     */
    usps_country_iso_2: "US" | "PR" | "GU";
    /**
     * Language
     * @description Language represented by 2 letter ISO Code (639-1)
     *
     * @enum {string}
     */
    usps_language: "en";
    /**
     * Primary Number
     * @description A house, rural route, contract box, or Post Office Box number. The numeric or alphanumeric component of an address preceding the street name. Often referred to as house number.
     * @example A298
     */
    primary_number: string;
    /**
     * Secondary Number
     * @description Number of the sub unit, apartment, suite etc
     * @example 123A
     */
    secondary_number: string;
    /**
     * Plus 4 Code
     * @description 4 digit ZIP add-on code.
     * @example 1234
     */
    plus_4_code: string;
    /**
     * First Address Line
     * @description The primary delivery line (usually the street address) of the address.
     * @example 12 Armstrong Ct Apt 12
     */
    line_1: string;
    /**
     * Second Address Line
     * @description Secondary delivery line of the address. Typically populated if the first line is the firm or building name.
     * @example 9450 Pinecroft Dr
     */
    line_2: string;
    /**
     * Last Line
     * @description Last line of the address comprising of city, state, zip code and zip+4
     * @example Greenwich CT 06830-1234
     */
    last_line: string;
    /**
     * ZIP Code
     * @description A 5-digit code that identifies a specific geographic delivery area. ZIP Codes can represent an area within a state, or a single building or company that has a very high mail volume.
     * @example 1234
     */
    zip_code: string;
    /**
     * ZIP + 4 Code
     * @description Nine-digit code that identifies a small geographic delivery area that is serviceable by a single carrier; appears in the last line of the address on a mail piece.
     * @example 12345-6789
     */
    zip_plus_4_code: string;
    /**
     * Update Key Number
     * @description Field that contains a number that uniquely identifies a record; used to identify the base record to which an add or delete transaction is being directed. The Update Key Number field is used only when applying transactions to the base file; it is not used in address matching and remains fixed for the life of the record. The field is alphanumeric and consists of the database segment code (V1, V2, W1, W2, X1, X2, Y1, Y2, Z1, or Z2) and eight characters containing an alphanumeric value ranging from 00000001 to AAAAAAAA.
     * @example 00000001
     */
    update_key_number: string;
    /**
     * Record Type Code
     * @description An alphabetic value that identifies the type of data in the record. - G = General delivery (5-Digit ZIP, ZIP + 4, and Carrier Route products) - H = High-rise (ZIP + 4 only) - F = Firm (ZIP + 4 only) - S = Street (5-Digit ZIP, ZIP + 4, and Carrier Route products) - P = PO Box (5-Digit ZIP, ZIP + 4, and Carrier Route products) - R = Rural route/contract (5-Digit ZIP, ZIP + 4, and Carrier Route products) - M = Multi-carrier (Carrier Route product only)
     * @enum {string}
     */
    record_type_code: "G" | "H" | "F" | "S" | "P" | "R" | "M" | "";
    /**
     * Carrier Route ID
     * @description A 4 character ID identifying the postal route for the address.
     * The first character indicates the route type. Specifically:
     * - "B" indicates PO Box
     * - "H" indicates highway
     * - "C" indicates city
     * - "G" indicates general
     * - "R" indicates rural
     * @example R012
     */
    carrier_route_id: string;
    /**
     * Street Pre-Directional Abbreviation
     * @description A geographic direction that precedes the street name.
     */
    street_pre_directional_abbreviation: string;
    /**
     * Street Name
     * @description The official name of a street as assigned by a local governing authority. The Street Name field contains only the street name and does not include directionals (EAST, WEST, etc.) or suffixes (ST, DR, BLVD, etc.). This element may also contain literals, such as PO BOX, GENERAL DELIVERY, USS, PSC, or UNIT.
     * @example GOSHEN
     */
    street_name: string;
    /**
     * Street Suffix Abbreviation
     * @description Code that is the standard USPS abbreviation for the trailing designator in a street address.
     * @example ST
     */
    street_suffix_abbreviation: string;
    /**
     * Street Post Directional Abbreviation
     * @description A geographic direction that follows the street name.
     */
    street_post_directional_abbreviation: string;
    /**
     * Building or Firm Name
     * @description The name of a company, building, apartment complex, shopping center, or other distinguishing secondary address information.
     * This field is normally used with firm and highrise records but may also contain literals such as “Postmaster” or “United States Postal Service.”
     * @example POSTMASTER
     */
    building_or_firm_name: string;
    /**
     * Address Secondary Abbreviation
     * @description A descriptive code used to identify the type of address secondary range information in the Address Secondary Range field.
     * This code may be useful in address matching, e.g., the secondary address numbers may indicate apartment, suite, or trailer numbers.
     */
    address_secondary_abbreviation: string;
    /**
     * Base Alternate Code
     * @description Code that specifies whether a record is a base (preferred) or alternate record.
     * Base records (represented as "B") can represent a range of addresses or an individual address, such as a firm record, while alternate records (represented as "A") are individual delivery points. Base records are generally preferred over alternate records.
     * Government deliveries will only be listed on alternate records with the appropriate government building indicator (federal, state, or city) set.
     * @enum {string}
     */
    base_alternate_code: "A" | "B" | "";
    /**
     * LACS Status Indicator
     * @description The Locatable Address Conversion Service (LACS) indicator describes records that have been converted to the LACS system (a product/system in a different USPS® product line that allows mailers to identify and convert a rural route address to a city-style address). Rural route and some city addresses are being modified to city-style addresses so that emergency services (e.g., ambulances, police) can find these addresses more efficiently.
     * - L = LACS address: The old (usually rural-route) address that has been converted for the LACS system.
     * - Blank = Not applicable
     * @enum {string}
     */
    lacs_status_indicator: "" | "L";
    /**
     * Government Building Indicator
     * @description An alphabetic value that identifies the type of government agency at the delivery point and/or whether a firm is the only delivery at an address. For this purpose, "address" is defined as the complete delivery line (e.g., complete street address and, if included as part of the firm record, the secondary abbreviation and/or address secondary number).
     * - A = City government building—alternates only
     * - B = Federal government building—alternates only
     * - C = State government building—alternates only
     * - D = Firm only—base and alternates
     * - E = City government building and firm only—alternates only
     * - F = Federal government building and firm only—alternates only
     * - G = State government building and firm only—alternates only
     * @enum {string}
     */
    government_building_indicator: "" | "A" | "B" | "C" | "D" | "E" | "F" | "G";
    /**
     * State Abbreviation
     * @description A 2-character abbreviation for the name of a state, U.S. territory, or armed forces ZIP Code designation. If APO/FPO/DPO, then the state abbreviation will be “AA,” “AE,” or “AP.”
     * @example NY
     */
    state_abbreviation: string;
    /**
     * State
     * @description Full name of a state, U.S. territory, or armed forces ZIP Code designation.
     * @example New York
     */
    state: string;
    /**
     * Municipality City State Key
     * @description Municipality City State Key. Currently blank.
     */
    municipality_city_state_key: string;
    /**
     * Urbanization City State Key
     * @description An index to the City State file that provides the urbanization name for this delivery range.
     * @example V18475
     */
    urbanization_city_state_key: string;
    /**
     * Preferred Last Line City State Key
     * @description In the Carrier Route, Five-Digit ZIP Code, Delivery Statistics, and ZIP + 4 products, an index to the City State product record that provides the preferred last-line name for this address range. In the City State product, the preferred last line city/state key contains the key value of a City State product record that has the default preferred or alternate preferred last-line key for a given ZIP Code.
     * @example V13916
     */
    preferred_last_line_city_state_key: string;
    /**
     * County Name
     * @description The name of the county or parish in which the 5-digit ZIP Code resides. If APO/FPO/DPO, then the county name will be blank.
     * @example Suffolk
     */
    county: string;
    /**
     * City Name
     * @description A valid city name for mailing purposes; appears in the last line of an address on a mail piece.
     * @example HOLTSVILLE
     */
    city: string;
    /**
     * City State Name Abbreviation
     * @description A standard 13-character abbreviation for a city/state name. This field is only used for names that are greater than 13 characters in length and have a city/state mailing name indicator of "Y." If the field is longer than 13 characters and the city/state mailing name indicator is "N," the field will be blank.
     * @example W TOWNSHEND
     */
    city_abbreviation: string;
    /**
     * Preferred Last Line City State Name
     * @description Field that contains the default preferred or alternate preferred last-line name for a ZIP Code.
     * @example AGUADA
     */
    preferred_city: string;
    /**
     * City State Name Facility Code
     * @description The type of locale identified in the city/state name. The facility may be a USPS facility, such as a post office, station, or branch, or it may be a non-postal place name. City/state name facility codes include the following:
     * - B = Branch
     * - C = Community post office (CPO)
     * - N = Non-postal community name, former USPS facility, or place name
     * - P = Post Office
     * - S = Station
     * - U = Urbanization
     * @enum {string}
     */
    city_state_name_facility_code: "B" | "C" | "N" | "P" | "S" | "U" | "Y" | "";
    /**
     * ZIP Classification Code
     * @description A field that describes the type of ZIP area that a 5-digit ZIP Code serves, e.g., a single educational institution, post office boxes only, or a single address that has unusually high mail volume or many different addresses.
     *  - M = Military ZIP Code
     *  - P = ZIP Code having only Post Office Boxes
     *  - U = Unique ZIP Code (ZIP assigned to a single organization)
     *  - Blank = Standard ZIP with many addresses assigned to it
     * @enum {string}
     */
    zip_classification_code: "" | "M" | "P" | "U";
    /**
     * City State Mailing Name Indicator
     * @description Specifies whether or not the city state name can be used as a last line of address on a mail piece.
     * - "Y = City/state name is a USPS-approved mailing name."
     * - "N = City/state name is not approved for mailing purposes."
     */
    city_state_mailing_name_indicator: string;
    /**
     * Carrier Route Rate Sortation and Merged 5-Digit Indicator
     * @description Identifies where automation Carrier Route rates are available and where the commingling of automation and non-automation mail, including Enhanced Carrier Routes and 5-digit presort, on the same pallet or in the same container is allowed.
     */
    carrier_route_rate_sortation: string;
    /**
     * Finance Number
     * @description A code assigned to Postal Service facilities (primarily Post Offices) to collect cost and statistical data and compile revenue and expense data.
     */
    finance_number: string | number;
    /**
     * Congressional District Number
     * @description A standard value identifying a geographic area within the United States served by a member of the U.S. House of Representatives. If Army/Air Force (APO), Fleet Post Office (FPO), or Diplomatic/Defense Post Office (DPO), this field will be blank. If there is only one member of Congress within a state, the code will be "AL" (at large).
     */
    congressional_district_number: string | number;
    /**
     * County Number
     * @description The Federal Information Processing Standard (FIPS) code assigned to a given county or parish within a state. In Alaska, it identifies a region within the state. If APO/FPO/DPO, and the record type is “S,” “H,” or “F,” the county number will be blank.
     */
    county_number: string | number;
    /**
     * United States Postal Service Address
     * @description Standard USA Address
     */
    UspsAddress: {
      id: components["schemas"]["ID"];
      dataset: components["schemas"]["usps_dataset"];
      country: components["schemas"]["usps_country"];
      country_iso: components["schemas"]["usps_country_iso"];
      country_iso_2: components["schemas"]["usps_country_iso_2"];
      language: components["schemas"]["usps_language"];
      primary_number: components["schemas"]["primary_number"];
      secondary_number: components["schemas"]["secondary_number"];
      plus_4_code: components["schemas"]["plus_4_code"];
      line_1: components["schemas"]["line_1"];
      line_2: components["schemas"]["line_2"];
      last_line: components["schemas"]["last_line"];
      zip_code: components["schemas"]["zip_code"];
      zip_plus_4_code: components["schemas"]["zip_plus_4_code"];
      update_key_number: components["schemas"]["update_key_number"];
      record_type_code: components["schemas"]["record_type_code"];
      carrier_route_id: components["schemas"]["carrier_route_id"];
      street_pre_directional_abbreviation: components["schemas"]["street_pre_directional_abbreviation"];
      street_name: components["schemas"]["street_name"];
      street_suffix_abbreviation: components["schemas"]["street_suffix_abbreviation"];
      street_post_directional_abbreviation: components["schemas"]["street_post_directional_abbreviation"];
      building_or_firm_name: components["schemas"]["building_or_firm_name"];
      address_secondary_abbreviation: components["schemas"]["address_secondary_abbreviation"];
      base_alternate_code: components["schemas"]["base_alternate_code"];
      lacs_status_indicator: components["schemas"]["lacs_status_indicator"];
      government_building_indicator: components["schemas"]["government_building_indicator"];
      state_abbreviation: components["schemas"]["state_abbreviation"];
      state: components["schemas"]["state"];
      municipality_city_state_key: components["schemas"]["municipality_city_state_key"];
      urbanization_city_state_key: components["schemas"]["urbanization_city_state_key"];
      preferred_last_line_city_state_key: components["schemas"]["preferred_last_line_city_state_key"];
      county: components["schemas"]["county"];
      city: components["schemas"]["city"];
      city_abbreviation: components["schemas"]["city_abbreviation"];
      preferred_city: components["schemas"]["preferred_city"];
      city_state_name_facility_code: components["schemas"]["city_state_name_facility_code"];
      zip_classification_code: components["schemas"]["zip_classification_code"];
      city_state_mailing_name_indicator: components["schemas"]["city_state_mailing_name_indicator"];
      carrier_route_rate_sortation: components["schemas"]["carrier_route_rate_sortation"];
      finance_number: components["schemas"]["finance_number"];
      congressional_district_number: components["schemas"]["congressional_district_number"];
      county_number: components["schemas"]["county_number"];
    };
    /**
     * Global Address
     * @description Global (non-US) Address in the US address format
     */
    UsaGlobalAddress: {
      id: components["schemas"]["ID"];
      /** @enum {undefined} */
      dataset: components["schemas"]["Dataset"];
      country: components["schemas"]["Country"];
      country_iso: components["schemas"]["CountryISO"];
      country_iso_2: components["schemas"]["CountryISO2"];
      language: components["schemas"]["Language"];
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      primary_number: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      secondary_number: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      plus_4_code: "";
      /** @description First line of address */
      line_1: string;
      /** @description Second line of address */
      line_2: string;
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      last_line: "";
      /** @description Partial postcode of address */
      zip_code: string;
      /** @description Full postal code of address */
      zip_plus_4_code: string;
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      update_key_number: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      record_type_code: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      carrier_route_id: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      street_pre_directional_abbreviation: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      street_name: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      street_suffix_abbreviation: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      street_post_directional_abbreviation: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      building_or_firm_name: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      address_secondary_abbreviation: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      base_alternate_code: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      lacs_status_indicator: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      government_building_indicator: "";
      /** @description State or province */
      state: string;
      /** @description Code of state or province (if available) */
      state_abbreviation: string;
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      municipality_city_state_key: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      urbanization_city_state_key: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      preferred_last_line_city_state_key: "";
      /** @description County name */
      county: string;
      /** @description City name */
      city: string;
      /** @description City name abbreviation (if available) */
      city_abbreviation: string;
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      preferred_city: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      city_state_name_facility_code: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      zip_classification_code: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      city_state_mailing_name_indicator: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      carrier_route_rate_sortation: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      finance_number: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      congressional_district_number: "";
      /**
       * @description Not available for non-US addresses
       * @enum {string}
       */
      county_number: "";
    };
    /** Address Resolution Response (USA) */
    UsaResolveAddressResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
      result:
        | components["schemas"]["UspsAddress"]
        | components["schemas"]["UsaGlobalAddress"];
    };
    /**
     * Longitude
     * Format: float
     * @description Longitude query for reverse geocoding.
     *
     * An accompanying latitude (lat=) query must be submitted for a valid reverse geocode query.
     *
     * @example -0.12767
     */
    AddressLongitudeParam: number;
    /**
     * Latitude
     * Format: float
     * @description Latitude query for reverse geocoding.
     *
     * An accompanying longitude (lon=) query must be submitted for a valid reverse geocode query.
     *
     * @example 51.503541
     */
    AddressLatitudeParam: number;
    /** Address Search Response */
    AddressResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
      result: {
        /** @description List of matching addresses */
        hits: (
          | components["schemas"]["PafAddress"]
          | components["schemas"]["MrAddress"]
          | components["schemas"]["NybAddress"]
          | components["schemas"]["WelshPafAddress"]
          | components["schemas"]["PafAliasAddress"]
        )[];
        /** Format: int32 */
        total: number;
        /**
         * Format: int32
         * @default 10
         * @example 10
         */
        limit: number;
        /** Format: int32 */
        page: number;
      };
    };
    /**
     * Licensee
     * @description Licensee object which can be defined by user
     */
    LicenseeEditable: {
      /**
       * @description Licensee individual or organisation name
       * @example Qwerty Widgets Limited
       */
      name?: string;
      /**
       * @description Licensee's first, second and third line address as well as post town concatenated by commas
       * @example 12 High Street, Manchester
       */
      address?: string;
      /**
       * @description Licensee's postcode
       * @example ID1 1QD
       */
      postcode?: string;
      /** @description A list of allowed URLs. An empty list means that whitelisting is disabled */
      whitelist?: string[];
      daily?: {
        /**
         * Format: int32
         * @description The maximum number of lookups this licensee can perform in a day. `null` indicates the limit is not active
         * @example 10000
         */
        limit?: number;
      };
    };
    /** Licensee */
    Licensee: components["schemas"]["LicenseeEditable"] &
      ({
        /**
         * @description An immutable ID provided for every licensee. Primarily used for paginated list requests.
         *
         * @example 56a11209ebe230380bf104c3
         */
        id: string;
        /**
         * @description Uniquely identifies a licensee for a key.
         *
         * Required to perform paid lookups for a specific licensee. Typically begins `sk_`.
         *
         * @example sl_ijoiqsxeQgXW2gkiE0X94
         */
        key: string;
        /**
         * @description Timestamp for when the licensee was created
         * @example 2016-01-21T17:14:49.971Z
         */
        createdAt: string;
        daily: {
          /**
           * Format: int32
           * @description The number lookups performed by the licensee on the day represented b `licesees.daily.updatedAt`
           * @example 232
           */
          count: number;
          /**
           * @description The timestamp when the limit was last used.
           * @example 2016-08-05T16:43:28.865Z
           */
          updatedAt: string;
        };
      } & {
        name: unknown;
        address: unknown;
        postcode: unknown;
        whitelist: unknown;
      });
    /** Licensee List Response */
    LicenseesResponse: {
      /** @description List of licensees */
      result: {
        licensees?: components["schemas"]["Licensee"][];
        /** @description Returns true if there are more licensees listed after the maximum number of results as implied by `limit` */
        hasMore?: boolean;
      };
      /** @enum {string} */
      message: "Success";
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
    };
    /** Licensee Response */
    LicenseeResponse: {
      result: components["schemas"]["Licensee"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** Config Object */
    Config: {
      /**
       * @description Timestamp for when the config was created
       * @example 2016-01-21T17:14:49.971Z
       */
      updatedAt: string;
      /**
       * @description Timestamp for when the config was updated
       * @example 2016-01-21T17:14:49.971Z
       */
      createdAt: string;
      /**
       * @description A unique name to identify the configuration payload
       * @example woocommerce
       */
      name: string;
      /**
       * @description A serialised payload of up to `4096` characters
       * @example {
       *   "removeOrganisation": false
       * }
       */
      payload: string;
    };
    /** Config List Response */
    ConfigsResponse: {
      /** @description List of configurations */
      result: {
        configs: components["schemas"]["Config"][];
      };
      /** @enum {string} */
      message: "Success";
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
    };
    /** Unauthorized Request Error Response */
    UnauthorizedResponse: components["schemas"]["ErrorResponse"] & {
      /**
       * Format: int32
       * @description `401X` type error response code
       */
      code: number;
      /** @description Unauthorized request error description */
      message: string;
    };
    /**
     * New Config Object
     * @description Required configuration object parameters
     */
    ConfigNewParam: {
      /**
       * @description A unique name to identify the configuration payload
       * @example woocommerce
       */
      name: string;
      /**
       * @description A serialised payload of up to `4096` characters
       * @example {
       *   "removeOrganisation": false
       * }
       */
      payload: string;
    };
    /** Config Response */
    ConfigResponse: {
      result: components["schemas"]["Config"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Configuration Name
     * @description User provided configuration object name
     * @example idpc-be
     */
    ConfigParam: string;
    /** Not Found Response */
    NotFoundResponse: components["schemas"]["ErrorResponse"] & {
      /**
       * Format: int32
       * @description `404X` type error response code
       */
      code: number;
      /** @description Resource not found error description */
      message: string;
    };
    /**
     * Update Config Object
     * @description Config object update parameters
     */
    ConfigUpdateParam: {
      /**
       * @description A serialised payload of up to `4096` characters
       * @example {
       *   "removeOrganisation": false
       * }
       */
      payload?: string;
    };
    EircBase: {
      id: components["schemas"]["ID"];
      /** @description Source of address */
      dataset: string;
      /**
       * @description   3 letter country code (ISO 3166-1)
       *
       * @enum {undefined}
       */
      country_iso: "IRL";
      /**
       * @description  2 letter country code (ISO 3166-1)
       *
       * @enum {string}
       */
      country_iso_2: "IE";
      /**
       * @description   Full country names (ISO 3166)
       *
       * @enum {string}
       */
      country: "Ireland";
      /**
       * @description Language represented by 2 letter ISO Code (639-1)
       *
       * @enum {undefined}
       */
      language: "en" | "ga";
      /** @description Address Line 1 */
      line_1: string;
      /** @description Address Line 2 */
      line_2: string;
      /** @description Address Line 3 */
      line_3: string;
      /** @description Address Line 4 */
      line_4: string;
      /** @description Address Line 5 */
      line_5: string;
      /** @description Address Line 6 */
      line_6: string;
      /** @description Address Line 7 */
      line_7: string;
      /** @description Address Line 8 */
      line_8: string;
      /** @description Address Line 9 */
      line_9: string;
      /**
       * @description The department or division within an organisation. If the department element exists, then the organisation must also exist.
       * @example Accounts Department
       */
      department: string;
      /**
       * @description Organisation name
       * @example Oak Tree Limited
       */
      organisation: string;
      /**
       * @description The sub-building refers to an apartment, flat or unit within a building.
       * @example Flat 1
       */
      sub_building_name: string;
      /**
       * @description The name given to the building. Prepended by sub building, if any, when the sub building does not appear on a line to itself. The building name is omitted if it is the same as either the Organisation or Building Group.
       * @example Rose Cottage
       */
      building_name: string;
      /**
       * @description A number associated with the whole building. The building number may have a numeric and an alphanumeric component, which are concatenated e.g. 2A, or alternatively will have a simple building number or a complex building number. The building number always relates to the whole building and not a sub-unit within it.
       * A complex building number may be one of the following:
       *   - Dual. Two number separated by '/' e.g. 63/64 = 63, 64
       *   - Sequence. An odd or even sequence of numbers with lower and upper bound separated by an underscore '_' e.g. `1_5` = 1,3,5 and `2_6` = 2,4,6
       *   - Range. A range of consecutive numbers with lower and upper bound separated by a dash '-' e.g. `63-66` = 63, 64, 56, 66
       * The building number never appears on a line by itself and can prepend Building Group, Primary Thoroughfare or Primary Locality.
       * @example 22
       */
      building_number: string;
      /**
       * @description A building group is a collection of buildings with a collective name, located on or near the same thoroughfare.
       * @example Marrian Terrace
       */
      building_group: string;
      /**
       * @description The name of the thoroughfare on which premises are located. It may appear on a line by itself or be appended to either a sub building or building number.
       *
       * Addresses with thoroughfares can sometimes have the thoroughfare excluded where a Building Group exists, such as a Retail Centre or Business Park, and the thoroughfare is not part of the Postal Address.
       * @example Griffith Road
       */
      primary_thoroughfare: string;
      /**
       * @description It is never present without a primary thoroughfare. The primary thoroughfare is dependent on the secondary thoroughfare and appears before the secondary thoroughfare in any address.
       *
       * Secondary thoroughfare are generally used to assist locating a primary thoroughfare.
       * @example Navan Road
       */
      secondary_thoroughfare: string;
      /**
       * @description First locality elements which can refer to areas, districts, industrial estates, towns, etc.
       *
       * The primary locality refers to the specific place the address is.
       *
       * In urban areas, the primary locality can be required to distinguish between two thoroughfares of the same name in the same district or town. Industrial estates with named thoroughfares are also held as localities. In rural areas the primary locality is generally a townland name.
       * @example Cookstown Industrial Estate
       */
      primary_locality: string;
      /**
       * @description Never present without a primary locality. The secondary locality has a wider geographic scope than the primary locality.
       *
       * It is the secondary locality therefore which differentiates addresses with the same primary locality name within the same county.
       *
       * Secondary localities are more likely to be required for rural addresses.
       *
       * Second locality elements which can refer to areas, districts, industrial estates, towns, etc
       *
       * The secondary locality helps identify where the primary locality is located.
       * @example Manorhamilton
       */
      secondary_locality: string;
      /**
       * @description Also known as the Post Town.
       *
       * The name of the post town associated with the premises for postal delivery purposes. This includes Dublin Postal Districts "Dublin 1" to "Dublin 24".
       *
       * The post town is a significant element of the Postal Address, however it is not always populated in an address. The official post office guide, Eolaí an Phoist4, describes post towns in the following manner:
       *
       * "A provincial postal address may include the name of a town or village several miles distant, with which the addressee has little or no connection, and, in some places, especially if this residence happens to be near a county boundary, the name of the neighbouring county instead of the county in which he actually resides. The explanation is that the main mail despatches have to be sent for more detailed sub division to certain centres known as POST TOWNS, chosen because of their accessibility and convenience."
       * @example Dublin 14
       */
      tertiary_locality: string;
      /**
       * @description One of the 26 Counties in the Republic of Ireland. These counties are sub-national divisions used for the purposes of administrative, geographical and political demarcation. Post County is the County associated with the Post Town, not the geographic county in which the building is located. The Post County is normally used as part of the Postal Address with some exceptions e.g. Dublin Postal Districts where the Post County is not used and some Post Towns (e.g. Tipperary, Kildare, etc.) that have the same name as the Post County.
       * @example Cork
       */
      post_county: string;
      /**
       * @description The seven character Eircode has an A65 F4E2 format. The Eircode is a mandatory address element. The last line of a Postal Address will contain the Eircode, displayed with a space. e.g. `A65 F4E2`.
       *
       * The Eircode is always the last line of a Postal Address generated within the state, e.g. if an address has four lines then the Eircode will be on its own on Address Line 5. For inbound international mail the country name IRELAND should be appended as the last line of the Postal Address.
       * @example A65 R2AF
       */
      eircode: string;
      /** @description The address reference is the An Post GeoDirectory address reference identifier used by the Universal Service Provider. */
      address_reference: string;
      longitude: components["schemas"]["Longitude"];
      latitude: components["schemas"]["Latitude"];
    };
    /**
     * Ireland ECAF Address
     * @description ECAF is the Eircode Address File which contains one record for each Postal Address. English language and Irish language versions are available. It is distributed as a flat file, details of data provision and updates are provided in section 2.
     */
    EcafAddress: components["schemas"]["EircBase"] & {
      /** @enum {string} */
      dataset?: "ecaf";
      /** @description The unique identifier in the ECAF is the `ecaf_id`. This unique identifier allows each address in the ECAF to be uniquely identified. It can also be used as index once the data has been imported into a relational database. This is a numeric field that can store values from 0 to 2,147,483,647. It is represented as a number up to 10 digits long. All other fields in ECAF are alphanumeric. */
      ecaf_id?: string;
    } & {
      ecaf_id: unknown;
    };
    /**
     * Ireland ECAD Address
     * @description The ECAD contains additional data for each ECAF address.
     */
    EcadAddress: components["schemas"]["EircBase"] & {
      /** @enum {string} */
      dataset?: "ecad";
      /**
       * @description Unique 10 digit ECAD ID
       * @example 17000000
       */
      ecad_id?: string;
      /**
       * @description Organisation ID
       * @example 10098783
       */
      organisation_id?: string;
      /**
       * @description Address Point ID
       * @example 10098783
       */
      address_point_id?: string;
      /**
       * @description Building ID
       * @example 10098783
       */
      building_id?: string;
      /**
       * @description Building Group ID
       * @example 10098783
       */
      building_group_id?: string;
      /**
       * @description Primary Thoroughfare ID
       * @example 10098783
       */
      primary_thoroughfare_id?: string;
      /**
       * @description Secondary Thoroughfare ID
       * @example 10098783
       */
      secondary_thoroughfare_id?: string;
      /**
       * @description Primary Locality ID
       * @example 10098783
       */
      primary_locality_id?: string;
      /**
       * @description Secondary Locality ID
       * @example 10098783
       */
      secondary_locality_id?: string;
      /**
       * @description The post town is a significant element of the Postal Address, however it is not always populated in an address. The official post office guide, Eolaí an Phoist1, describes post towns in the following manner:
       *
       * "A provincial postal address may include the name of a town or village several miles distant, with which the addressee has little or no connection, and, in some places, especially if this residence happens to be near a county boundary, the name of the neighbouring county instead of the county in which he actually resides. The explanation is that the main mail despatches have to be sent for more detailed sub division to certain centres known as post towns, chosen because of their accessibility and convenience."
       */
      post_town?: string;
      /**
       * @description Post Town ID
       * @example 10098783
       */
      post_town_id?: string;
      /**
       * @description Post County ID
       * @example 10098783
       */
      post_county_id?: string;
      /**
       * @description NUA means "non-unique address".
       *
       * The NUA field contains `true` when the address is a non-unique address, and `false` when it is a unique address.
       *
       * Ireland has a very high level of non-unique addresses (NUA), i.e. the address does not contain a unique building number or name. Approximately 35% of all Irish addresses are non-unique which equates to 600,000 addresses.
       *
       * The typical example of NUA addressing is where every address in a townland is the same. The way that post is delivered is by local knowledge of postal delivery personnel of which addressee lives in which house.
       *
       * N.B. For a NUA address, it is impossible to match to a unique record in the ECAD and assign an Eircode.
       */
      nua?: boolean;
      /**
       * @description Gaeltact refers to a district where the Irish government recognises that the Irish language is the predominant language.
       *
       * Returns `true` if address is in a Gaeltacht area and `false` if not.
       */
      gaeltacht?: boolean;
      /**
       * @description Addresses points can assume one of the following values:
       *
       * - Residential Address Point. This type of address point has one residential addresses associated with it.
       * - Non-Residential Address Point. This type of address point has one or more non-residential address (business, club or other organisation) associated with it.
       * - Mixed Address Point. This is a special case where the residential and non residential addresses in the building are essentially the same address. The typical example is a farm house on an active farm. It is important to note that this is a special case. In general a building with both residential and non-residential addresses (e.g. an apartment over a shop) will receive two address points, one commercial and one residential, and hence two Eircodes.
       *
       * Buildings can contain multiple address points of type Residential and/or Non-Residential.
       */
      address_type?: string;
      /**
       * @description The building type can assume one of the following values:
       *
       * - Single Occupancy Residential Building. This type of building contains one residential address.
       * - Multi Occupancy Residential Building. This type of building contains multiple residential addresses.
       * - Single Occupancy Non-Residential Building. This type of building contains one non-residential address (business, club or other organisation).
       * - Multi Occupancy Non-Residential Building. This type of building contains multiple non-residential addresses (business, club or other organisation).
       * - Multi Occupancy Mixed Use Building. This type of building contains multiple residential and non- residential addresses.
       *
       * Buildings can also have a more specific address types such as a Hospital, School, Shopping Centre, etc.
       */
      building_address_type?: string;
      /**
       * @description The building group type can be:
       *
       * - Residential Building Group. This type of building group contains buildings with residential addresses only.
       * - Non-Residential Building Group This type of building group contains buildings with non-residential addresses (business, club or other organisation) only.
       * - Mixed Building Group. This type of building group contains buildings with residential and non-residential addresses. Can also have a more specific address type such as a Hospital, School, Shopping Centre, etc.
       *
       * Building groups can also have a more specific address type such as a Hospital, School, Shopping Centre, etc.
       */
      building_group_address_type?: string;
      /**
       * @description The locality type can be:
       *   - Rural Locality. This is generally a townland.
       *   - Industrial Estate. Industrial Estate, Industrial Park, Business Campus, etc.
       *   - Shopping District. Shopping Centre.
       *   - Housing Estate. Residential Housing Estate.
       *   - Village. Based on Census 2011 population < 1,500.
       *   - Town. Based on Census 2011 population > 1,500.
       *   - Urban Area. Wholly within a village/town/city e.g. Rathmines.
       *   - Suburban Locality. This is an area that is both rural and urban, as it is both a townland, and also an area name applied to houses in a town, as the town has extended partially into the townland.
       *
       * Where the locality is also the post town, the type can be:
       *   - Village. Based on Census 2011 population < 1,500
       *   - Town. Based on Census 2011 population > 1,500
       *   - Postal District. Dublin 1 to 24
       *   - City. Dublin, Cork, Limerick, Galway or Waterford
       */
      primary_locality_address_type?: string;
      /**
       * @description The locality type can be:
       *   - Rural Locality. This is generally a townland.
       *   - Industrial Estate. Industrial Estate, Industrial Park, Business Campus, etc.
       *   - Shopping District. Shopping Centre.
       *   - Housing Estate. Residential Housing Estate.
       *   - Village. Based on Census 2011 population < 1,500.
       *   - Town. Based on Census 2011 population > 1,500.
       *   - Urban Area. Wholly within a village/town/city e.g. Rathmines.
       *   - Suburban Locality. This is an area that is both rural and urban, as it is both a townland, and also an area name applied to houses in a town, as the town has extended partially into the townland.
       *
       * Where the locality is also the post town, the type can be:
       *   - Village. Based on Census 2011 population < 1,500
       *   - Town. Based on Census 2011 population > 1,500
       *   - Postal District. Dublin 1 to 24
       *   - City. Dublin, Cork, Limerick, Galway or Waterford
       */
      secondary_locality_address_type?: string;
      /** @description Describes the type of building, e.g. detached, semi-detached, bungalow. */
      building_type?: string;
      /**
       * @description A Yes/No field, indicating whether or not the building is a holiday home.
       * @enum {undefined}
       */
      holiday_home?: "N" | "Y" | "";
      /**
       * @description A Yes/No field, indicating whether or not the building is under construction.
       * @enum {undefined}
       */
      under_construction?: "N" | "Y" | "";
      /**
       * @description Can be one of:
       *
       * - `R` Residential
       * - `C` Commercial
       * - `B` Both
       * - `U` Unknown
       * @enum {undefined}
       */
      building_use?: "R" | "C" | "B" | "U";
      /**
       * @description A Yes/No field, indicating whether the building is vacant.
       * @enum {undefined}
       */
      vacant?: "Y" | "N" | "";
      /**
       * @description A Yes/No field, indicating whether the organisation is vacant.
       * @enum {undefined}
       */
      org_vacant?: "Y" | "N" | "";
      /** @description The NACE Code for the Category. */
      nace_code?: string;
      /** @description Name of the NACE Category */
      nace_category?: string;
      /** @description Name of local authority */
      local_authority?: string;
      /**
       * @description Unique Identifier for Electoral Divisions 2017 data.
       *
       * Note that this field is subject to breaking changes if a new generation of government data IDs is released. Currently this uses 2017 IDs. Contact us to be notified ahead of his change.
       */
      ded_id?: string;
      /**
       * @description Unique Identifier for the Small Area 2017 data.
       *
       * Note that this field is subject to breaking changes if a new generation of government data IDs is released. Currently this uses 2017 IDs. Contact us to be notified ahead of his change.
       */
      small_area_id?: string;
      /**
       * @description Unique Identifier for townland 2017 data.
       *
       * Note that this field is subject to breaking changes if a new generation of government data IDs is released. Currently this uses 2017 IDs. Contact us to be notified ahead of his change.
       */
      townland_id?: string;
      /**
       * @description Unique Identifier for the 7 Gaeltacht areas 2017 data.
       *
       * Note that this field is subject to breaking changes if a new generation of government data IDs is released. Currently this uses 2017 IDs. Contact us to be notified ahead of his change.
       */
      gaeltacht_id?: string;
      /** @description An Post sorting information. */
      postaim_presort_61?: string;
      /** @description An Post sorting information. */
      postaim_presort_152?: string;
      /** @description An Post publicity post zone information. */
      publicity_post_zone?: string;
    } & {
      organisation_id: unknown;
      address_point_id: unknown;
      building_id: unknown;
      building_group_id: unknown;
      primary_thoroughfare_id: unknown;
      secondary_thoroughfare_id: unknown;
      primary_locality_id: unknown;
      secondary_locality_id: unknown;
      post_town: unknown;
      post_town_id: unknown;
      post_county_id: unknown;
      nua: unknown;
      gaeltacht: unknown;
      address_type: unknown;
      building_address_type: unknown;
      building_group_address_type: unknown;
      primary_locality_address_type: unknown;
      secondary_locality_address_type: unknown;
      building_type: unknown;
      holiday_home: unknown;
      under_construction: unknown;
      building_use: unknown;
      vacant: unknown;
      org_vacant: unknown;
      nace_code: unknown;
      nace_category: unknown;
      local_authority: unknown;
      ded_id: unknown;
      small_area_id: unknown;
      townland_id: unknown;
      gaeltacht_id: unknown;
      postaim_presort_61: unknown;
      postaim_presort_152: unknown;
      publicity_post_zone: unknown;
    };
  };
}

export interface operations {
  /**
   * Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
   *
   * The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
   *
   * ## Postcode Not Found
   *
   * Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
   *
   * ```json
   * {
   *   "code": 4040,
   *   "message": "Postcode not found",
   *   "suggestions": ["SW1A 0AA"]
   * }
   * ```
   *
   * ### Suggestions
   *
   * If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
   *
   * If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
   *
   * The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
   *
   * ## Multiple Residence
   *
   * A small number of postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
   */
  Postcodes: {
    parameters: {
      path: {
        /** Postcode to retrieve */
        postcode: components["schemas"]["paf_postcode"];
      };
      query: {
        api_key?: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
        page?: components["schemas"]["PageParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["PostcodeResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Postcode Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["PostcodeNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
   *
   * You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
   *
   * UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
   *
   * ## Testing
   *
   * To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
   *
   * They are the following:
   *
   * - `0` Returns a successful UDPRN lookup response
   *   `2000`
   * - `-1` Returns "UDPRN not found", error `4044`
   * - `-2` Returns "no lookups remaining", error `4020`
   * - `-3` Returns "daily (or individual) lookup limit breached",
   *   error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  UDPRN: {
    parameters: {
      path: {
        /** UDPRN to be retrieved */
        udprn: string;
      };
      query: {
        api_key?: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UDPRNResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
   *
   * UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
   *
   * ## Testing
   *
   * To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
   *
   * - `0` Returns a successful UMPRN lookup response `2000`
   * - `-1` Returns "UMPRN not found", error `4044`
   * - `-2` Returns "no lookups remaining", error `4020`
   * - `-3` Returns "daily (or individual) lookup limit breached", error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   *
   * ### Pricing
   *
   * Per lookup charges apply. Empty responses are not charged.
   */
  UMPRN: {
    parameters: {
      path: {
        /** UMPRN to be retrieved */
        umprn: string;
      };
      query: {
        api_key?: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UMPRNResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns public information on key. Currently only returns whether the key is currently useable via the `available` property. Use this to discover if the key is useable before making further requests.
   *
   * You may pass both API Keys (beginning `ak_`) and Sub-licensed Keys (beginning `sl_`).
   * ## Testing
   *
   * To test your implementation of our API, you may use the following test keys.
   *
   * - **iddqd** Availability will return as `true`
   * - **idkfa** Availability will return as `false`
   */
  KeyAvailability: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyResponse"];
        };
      };
      /** Invalid Key */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Returns private data on the key including remaining lookups, available datasets and usage limits. */
  KeyDetails: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyDetailsResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Reports the number of lookups consumed on a key for a range of days.
   *
   * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
   */
  KeyUsage: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** A start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time. */
        start?: components["schemas"]["StartParam"];
        /** An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used. */
        end?: components["schemas"]["EndParam"];
        tags?: components["schemas"]["TagsParam"];
        /** Sublicensed keys only. This will restrict the analysed dataset to a specific licensee. */
        licensee?: components["schemas"]["LicenseeParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyUsageResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
  };
  /**
   * Reports lookup information on a key for paid lookups.
   *
   * This method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).
   *
   * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
   *
   * ## Download Usage History (CSV)
   *
   * `GET /keys/:key/lookups`
   *
   * Returns a CSV download of lookups performed and associated information.
   *
   * Note that the Content-Type returned will be CSV (text/csv). For a non 200 response, the `Content-Type` will revert to JSON with the error code and message embedded.
   *
   * ## Data Redaction
   *
   * Personally Identifiable Data (PII) caught in this your usage log (including IP, search term and URL data) will be redacted on a weekly basis.
   *
   * By default, PII will be redacted if it is older than 21 days. This timeframe can be configured from your dashboard.
   *
   * You may prevent PII collection altogether by setting the interval to `0` days.
   */
  KeyLogs: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** An start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time. */
        start?: components["schemas"]["StartParam"];
        /** An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used. */
        end?: components["schemas"]["EndParam"];
        /** Sublicensed keys only. This will restrict the analysed dataset to a specific licensee. */
        licensee?: components["schemas"]["LicenseeParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "text/csv": string;
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
  };
  /**
   * The address autocomplete API returns a list of address suggestions that match the query ordered by relevance.
   *
   * This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
   *
   * Consider using our Address Autocomplete JavaScript libraries to add address lookup to a form in moments.
   *
   * ## Implementing Address Autocomplete
   *
   * Rapid address autocompletion using our Address Autocomplete API is a 2 step process.
   *
   * 1. Retrieve partial address suggestions via `/autocomplete/addresses`
   * 2. Retrieve the entire address with the ID provided in the suggestion
   *
   * Step 2 will decrement your lookup balance.
   *
   * Please note, this API is not intended to be a free standalone resource.
   *
   * ## Filters
   *
   * You can strictly narrow your result by adding filters to your querystring. For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
   *
   * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
   *
   * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
   *
   * All filters can accept multiple terms unless stated otherwise below.
   *
   * Filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
   *
   * A maximum of **10** terms are allowed across all filters.
   *
   * ## Biases
   *
   * You can boost certain addresses results that match specific address criteria. All bias searches are prefixed with `bias_`.
   *
   * Biasing (unlike filtering) also allow unmatched addresses to appear with lower precedence.
   *
   * For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
   *
   * No bias effect applies to bias terms that are invalid. e.g. `bias_postcode=SW1A2AAA`
   *
   * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
   *
   * All biases can accept multiple terms unless stated otherwise below.
   *
   * A combined maximum of **5** terms are allowed across all biases.
   *
   * ## Suggestion Format
   *
   * The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
   *
   * ## Rate Limiting
   *
   * You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
   *
   * | Header                  | Description                                                                            |
   * | ----------------------- | -------------------------------------------------------------------------------------- |
   * | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
   * | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
   * | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
   *
   * ## Pricing
   *
   * This API currently does not affect your balance. However, resolving a suggestion into a full address requires a paid request.
   *
   * Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
   */
  AddressAutocomplete: {
    parameters: {
      query: {
        api_key?: components["schemas"]["ApiKeyParam"];
        /** Specifies the address you wish to query. Query can be shortened to `q=` */
        query?: string;
        context?: components["schemas"]["Context"];
        /** Limits number of address suggestions unless a postcode is detected. In this instance entire list of addreses for that postcode is returned. */
        limit?: components["schemas"]["LimitParam"];
        postcode_outward?: components["schemas"]["PostcodeOutwardParam"];
        postcode?: components["schemas"]["PostcodeParam"];
        postcode_area?: components["schemas"]["PostcodeAreaParam"];
        postcode_sector?: components["schemas"]["PostcodeSectorParam"];
        post_town?: components["schemas"]["PostTownParam"];
        uprn?: components["schemas"]["UPRNParam"];
        country?: components["schemas"]["CountryParam"];
        postcode_type?: components["schemas"]["PostcodeTypeParam"];
        su_organisation_indicator?: components["schemas"]["SmallUserParam"];
        box?: components["schemas"]["BoxParam"];
        bias_postcode_outward?: components["schemas"]["BiasPostcodeOutwardParam"];
        bias_postcode?: components["schemas"]["BiasPostcodeParam"];
        bias_postcode_area?: components["schemas"]["BiasPostcodeAreaParam"];
        bias_postcode_sector?: components["schemas"]["BiasPostcodeSectorParam"];
        bias_post_town?: components["schemas"]["BiasPosttownParam"];
        bias_thoroughfare?: components["schemas"]["BiasThoroughfareParam"];
        bias_country?: components["schemas"]["BiasCountryParam"];
        bias_lonlat?: components["schemas"]["BiasLonLatParam"];
        bias_ip?: components["schemas"]["BiasIpParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        headers: {
          /** The maximum number of requests that can be made in 5 minutes */
          "X-RateLimit-Limit"?: number;
          /** The remaining requests within the current rate limit window */
          "X-RateLimit-Remaining"?: number;
          /** The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds. */
          "X-RateLimit-Reset"?: number;
        };
        content: {
          "application/json": components["schemas"]["AutocompleteResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
  };
  /**
   * Resolves an address autocompletion by its address ID.
   *
   * Resolved addresses (including global addresses) are returned in a UK format (up to 3 address lines) using UK nomenclature (like postcode and county).
   */
  Resolve: {
    parameters: {
      path: {
        /** ID of address suggestion */
        address: string;
      };
      query: {
        api_key?: components["schemas"]["ApiKeyParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GbrResolveAddressResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Resolves an address autocompletion by its address ID.
   *
   * Resolved addresses (including global addresses) are returned in a US format (up to 2 address lines) using US nomenclature (like zipcode, state and city).
   */
  ResolveUsa: {
    parameters: {
      path: {
        /** ID of address suggestion */
        address: string;
      };
      query: {
        api_key?: components["schemas"]["ApiKeyParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UsaResolveAddressResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
   *
   * If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
   *
   * This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
   *
   * For address autocomplete, see our address finder API - which is designed for speed and address completion.
   *
   * ## Reverse Geocoding
   *
   * Return a list of addresses around a point using the lon= and lat= querystring arguments. Addresses will be sorted in order of distance to the point. The search radius is 100m.
   *
   * ## Filters
   *
   * You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
   *
   * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
   *
   * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
   *
   * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
   *
   * All filters can accept multiple terms unless stated otherwise below.
   *
   * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
   *
   * A combined maximum of 5 terms are allowed across all filters.
   *
   * ## Biases
   *
   * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
   *
   * Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
   *
   * For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
   *
   * If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
   *
   * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
   *
   * All biases can accept multiple terms unless stated otherwise below.
   *
   * A combined maximum of 5 terms are allowed across all biases.
   *
   * ## Search by Postcode and Building Name or Number
   *
   * Search by postcode and building attribute with the postcode filter and query argument. E.g. For "SW1A 2AA Prime Minister" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
   *
   * The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
   *
   * #### Search By UPRN
   *
   * Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
   *
   * ## Testing
   *
   * - **ID1 1QD** Returns a successful query response `2000`
   * - **ID1 KFA** Returns an empty query response `2000`
   * - **ID1 CLIP** Returns "no lookups remaining" error `4020`
   * - **ID1 CHOP** Returns "daily (or individual) lookup limit breached" error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  Addresses: {
    parameters: {
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        /** Specifies the address you wish to query. Query can be shortened to `q=` */
        query?: string;
        limit?: components["schemas"]["LimitParam"];
        page?: components["schemas"]["PageParam"];
        filter?: components["schemas"]["FilterParam"];
        lon?: components["schemas"]["AddressLongitudeParam"];
        lat?: components["schemas"]["AddressLatitudeParam"];
        postcode_outward?: components["schemas"]["PostcodeOutwardParam"];
        postcode?: components["schemas"]["PostcodeParam"];
        postcode_area?: components["schemas"]["PostcodeAreaParam"];
        postcode_sector?: components["schemas"]["PostcodeSectorParam"];
        post_town?: components["schemas"]["PostTownParam"];
        uprn?: components["schemas"]["UPRNParam"];
        country?: components["schemas"]["CountryParam"];
        postcode_type?: components["schemas"]["PostcodeTypeParam"];
        su_organisation_indicator?: components["schemas"]["SmallUserParam"];
        box?: components["schemas"]["BoxParam"];
        bias_postcode_outward?: components["schemas"]["BiasPostcodeOutwardParam"];
        bias_postcode?: components["schemas"]["BiasPostcodeParam"];
        bias_postcode_area?: components["schemas"]["BiasPostcodeAreaParam"];
        bias_postcode_sector?: components["schemas"]["BiasPostcodeSectorParam"];
        bias_post_town?: components["schemas"]["BiasPosttownParam"];
        bias_thoroughfare?: components["schemas"]["BiasThoroughfareParam"];
        bias_country?: components["schemas"]["BiasCountryParam"];
        bias_lonlat?: components["schemas"]["BiasLonLatParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["AddressResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Postcode Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["PostcodeNotFoundResponse"];
        };
      };
    };
  };
  /** Returns a list of licensees for a key. */
  ListLicensees: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** Specify ID of the licensee after which you would like to list results */
        starting_after?: number;
        user_token?: components["schemas"]["UserTokenParam"];
        /** Specify the maximum number of results to return per page. Default and maximum is `100`. */
        limit?: components["schemas"]["LimitParam"];
        /** Filter result by licensee name. Query can be shortened to `q=` */
        query?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseesResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
  };
  /** Create a licensee for the specified API Key. */
  CreateLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LicenseeEditable"];
      };
    };
  };
  /** Returns licensee information as identified by the licensee key. */
  RetrieveLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
  };
  /** Update Licensee */
  UpdateLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LicenseeEditable"];
      };
    };
  };
  /** Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us. */
  DeleteLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: int32
               * @example 1
               */
              deleted: number;
            };
            /**
             * Format: int32
             * @enum {integer}
             */
            code: 2000;
            /** @enum {string} */
            message: "Success";
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
    };
  };
  /** Lists configurations associated with a key */
  ListConfigs: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigsResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
    };
  };
  /** Create a config */
  CreateConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfigNewParam"];
      };
    };
  };
  /** Retrieve config object by name */
  RetrieveConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
  };
  /** Updates configuration object */
  UpdateConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfigUpdateParam"];
      };
    };
  };
  /** Permanently deletes a configuration object. */
  DeleteConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
      query: {
        user_token?: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: int32
               * @example 1
               */
              deleted: number;
            };
            /**
             * Format: int32
             * @enum {integer}
             */
            code: 2000;
            /** @enum {string} */
            message: "Success";
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
  };
}

export interface external {}

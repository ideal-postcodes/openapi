/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/postcodes/{postcode}": {
    /**
     * Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
     *
     * The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
     *
     * ## JavaScript Example
     *
     * ```javascript
     * const { Client, postcodes } = require("@ideal-postcodes/core-node");
     *
     * const api_key = "iddqd";
     *
     * const client = new Client({ api_key: "iddqd" });
     *
     * await postcodes.retrieve(client, "ID1 1QD", { query: { api_key } });
     * ```
     *
     * This API models postcodes as a HTTP resource. The above example provides a thin JavaScript abstraction and more control over the HTTP request and response. The JavaScript client also provides a number of terser helper methods like [`client.lookupPostcode`](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
     *
     * If you wish to quickly add Postcode Lookup driven address finder on your page, see our [Postcode Lookup plugin](/postcode-lookup) and [associated demos](/postcode-lookup-demo).
     *
     * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
     *
     * ## Postcode Not Found
     *
     * Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
     *
     * ```json
     * {
     *   "code": 4040,
     *   "message": "Postcode not found",
     *   "suggestions": ["SW1A 0AA"]
     * }
     * ```
     *
     * ### Suggestions
     *
     * If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
     *
     * If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
     *
     * The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
     *
     * ## Multiple Residence
     *
     * A small number of  postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
     *
     * ```javascript
     * const { lookupPostcode, Client } = require("@ideal-postcodes/core-node");
     *
     * const client = new Client({ api_key: "iddqdmr" });
     *
     * await lookupPostcode({ client, postcode: "CV4 7AL", page: 1 });
     * ```
     *
     * ## Testing
     *
     * We have a range of test postcodes that yield both successful and unsuccessful responses to your request. They are the following
     *
     * - `ID1 1QD` Returns a successful Postcode Lookup response `2000`
     * - `ID1 KFA` Returns "postcode not found", error `4040`
     * - `ID1 CLIP` Returns "no lookups remaining", error `4020`
     * - `ID1 CHOP` Returns "daily (or individual) lookup limit breached", error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["Postcodes"];
  };
  "/udprn/{udprn}": {
    /**
     * Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
     *
     * You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
     *
     * UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
     *
     * ## Testing
     *
     * To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
     *
     * They are the following:
     *
     * - `0` Returns a successful UDPRN lookup response
     *   `2000`
     * - `-1` Returns "UDPRN not found", error `4044`
     * - `-2` Returns "no lookups remaining", error `4020`
     * - `-3` Returns "daily (or individual) lookup limit breached",
     *   error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["UDPRN"];
  };
  "/umprn/{umprn}": {
    /**
     * Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
     *
     * UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
     *
     * ## Testing
     *
     * To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
     *
     * - `0` Returns a successful UMPRN lookup response `2000`
     * - `-1` Returns "UMPRN not found", error `4044`
     * - `-2` Returns "no lookups remaining", error `4020`
     * - `-3` Returns "daily (or individual) lookup limit breached", error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     *
     * ### Pricing
     *
     * Per lookup charges apply. Empty responses are not charged.
     */
    get: operations["UMPRN"];
  };
  "/keys/{key}": {
    /**
     * Returns public information on key. Currently only returns whether the key is currently useable via the `available` property. Use this to discover if the key is useable before making further requests.
     *
     * You may pass both API Keys (beginning `ak_`) and Sub-licensed Keys (beginning `sl_`).
     * ## Testing
     *
     * To test your implementation of our API, you may use the following test keys.
     *
     * - **iddqd** Availability will return as `true`
     * - **idkfa** Availability will return as `false`
     */
    get: operations["KeyAvailability"];
  };
  "/keys/{key}/details": {
    /** Returns private data on the key including remaining lookups, available datasets and usage limits. */
    get: operations["KeyDetails"];
  };
  "/keys/{key}/usage": {
    /**
     * Reports the number of lookups consumed on a key for a range of days.
     *
     * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
     */
    get: operations["KeyUsage"];
  };
  "/keys/{key}/lookups": {
    /**
     * Reports lookup information on a key for paid lookups.
     *
     * This method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).
     *
     * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
     *
     * ## Download Usage History (CSV)
     *
     * `GET /keys/:key/lookups`
     *
     * Returns a CSV download of lookups performed and associated information.
     *
     * Note that the Content-Type returned will be CSV (text/csv). For a non 200 response, the `Content-Type` will revert to JSON with the error code and message embedded.
     *
     * ## Data Redaction
     *
     * Personally Identifiable Data (PII) caught in this your usage log (including IP, search term and URL data) will be redacted on a weekly basis.
     *
     * By default, PII will be redacted if it is older than 21 days. This timeframe can be configured from your dashboard.
     *
     * You may prevent PII collection altogether by setting the interval to `0` days.
     */
    get: operations["KeyLogs"];
  };
  "/autocomplete/addresses": {
    /**
     * The address autocomplete API returns a list of address suggestions that match the query ordered by relevance score.
     *
     * This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
     *
     * If you wish to quickly add address autocompletion to your address forms, see [Address Finder](/address-finder) and [associated demos](/address-finder-demo).
     *
     * ## Implementing Address Autocomplete
     *
     * Retrieving addresses using Address Autocomplete is a 2 step process.
     *
     * 1. Retrieve partial address suggestions via `/autocomplete/addresses`
     * 2. Retrieve the entire address by following the URL provided by the suggestion
     *
     * Step 2 will decrement your lookup balance.
     *
     * Please note, this API is not intended to be a free standalone resource.
     *
     * ### JavaScript Example
     *
     * #### Step 1. Retrieve a list of suggestions
     *
     * ```javascript
     * const { Client, autocomplete } = require("@ideal-postcodes/core-node");
     *
     * const response = await autocomplete.list(client, {
     *   query: {
     *     query: "221b bake",
     *     api_key: "iddqd",
     *   },
     * });
     * ```
     *
     * #### Step 2. Resolve a suggestion retrieved above for a full address
     *
     * ```javascript
     * const { lookupUdprn } = require("@ideal-postcodes/core-node");
     *
     * const udprn = 17646242;
     *
     * await lookupUdprn({ client, udprn });
     * ```
     *
     * ## Filters
     *
     * You can strictly narrow your result by adding filters to your querystring which correspond with an address attribute.
     *
     * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
     *
     * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
     *
     * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are <code>OR</code>'ed, i.e. the matching result sets are combined.
     *
     * All filters can accept multiple terms unless stated otherwise below.
     *
     * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are <code>AND</code>'ed, i.e. each additional filter narrows the result set.
     *
     * A maximum of **10** terms are allowed across all filters.
     *
     * ## Biases
     *
     * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
     *
     * Biased searches, unlike filtered searches, also allow unmatched addresses to appear. These will rank lower.
     *
     * For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
     *
     * No bias effect applies to bias terms that are invalid.
     * e.g. `bias_postcode=SW1A2AAA`
     *
     * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
     *
     * All biases can accept multiple terms unless stated otherwise below.
     *
     * A combined maximum of **5** terms are allowed across all biases.
     *
     * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
     *
     * ## Suggestion Format
     *
     * The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
     *
     * ## Querying with a Postcode
     *
     * - If a postcode is passed as a query, all addresses for that postcode will be listed as the result if the limit parameter is not supplied
     * - If a postcode forms only part of the query, your autocomplete results will be filtered by that postcode
     *
     * ## Querying Multiple Residence
     *
     * For Multiple Residence enabled keys, any Multiple Residence households will also return a UMPRN id. This can be retrieved with the `/umprn/:id` endpoint.
     * Note that Multiple Residence households will always have:
     * - A parent premise with a UDPRN
     * - A single UDPRN premise may have many Multiple Residence households with different UMPRNs.
     *
     * ## Rate Limiting
     *
     * You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
     *
     * | Header                  | Description                                                                            |
     * | ----------------------- | -------------------------------------------------------------------------------------- |
     * | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
     * | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
     * | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
     *
     * ## Pricing
     *
     * This API currently does not affect your balance. However, subsequent searches require a paid request (e.g. a UDPRN search). This paid request, will yield the complete address.
     *
     * Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
     *
     * ## Testing
     *
     * `ID1 1QD` will return address suggestions, that when retrieved via `/udprn/:id` will not affect your balance.
     */
    get: operations["AddressAutocomplete"];
  };
  "/autocomplete/addresses/{address}/gbr": {
    /**
     * Resolves an address autocompletion by its address ID.
     *
     * Resolved addresses (including global addresses) are returned in a UK format (up to 3 address lines) using UK nomenclature (like postcode and county).
     */
    get: operations["Resolve"];
  };
  "/addresses": {
    /**
     * Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
     *
     * If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
     *
     * This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
     *
     * For address finder, see our address finder API - which is designed for speed and ergonomics.
     *
     * ### JavaScript Example
     *
     * ```javascript
     * const { Client, lookupAddress } = require("@ideal-postcodes/core-node");
     *
     * const client = new Client({ api_key: "iddqd" });
     *
     * await lookupAddress({ client, query: "10 Brompton Rd" });
     * ```
     *
     * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#search-for-an-address)
     *
     * ## Filters
     *
     * You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
     *
     * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
     *
     * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
     *
     * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
     *
     * All filters can accept multiple terms unless stated otherwise below.
     *
     * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
     *
     * A combined maximum of 5 terms are allowed across all filters.
     *
     * ## Biases
     *
     * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
     *
     * Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
     *
     * For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
     *
     * If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
     *
     * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
     *
     * All biases can accept multiple terms unless stated otherwise below.
     *
     * A combined maximum of 5 terms are allowed across all biases.
     *
     * ## Search by Postcode and Building Name or Number
     *
     * Search by postcode and building attribute with the postcode filter and query argument. E.g. For "SW1A 2AA Prime Minister" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
     *
     * The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
     *
     * #### Search By UPRN
     *
     * Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
     *
     * ## Testing
     *
     * - **ID1 1QD** Returns a successful query response `2000`
     * - **ID1 KFA** Returns an empty query response `2000`
     * - **ID1 CLIP** Returns "no lookups remaining" error `4020`
     * - **ID1 CHOP** Returns "daily (or individual) lookup limit breached" error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["Addresses"];
  };
  "/keys/{key}/licensees": {
    /** Returns a list of licensees for a key. */
    get: operations["ListLicensees"];
    /** Create a licensee for the specified API Key. */
    post: operations["CreateLicensee"];
  };
  "/keys/{key}/licensees/{licensee}": {
    /** Returns licensee information as identified by the licensee key. */
    get: operations["RetrieveLicensee"];
    /** Update Licensee */
    put: operations["UpdateLicensee"];
    /** Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us. */
    delete: operations["DeleteLicensee"];
  };
  "/keys/{key}/configs": {
    /** Lists configurations associated with a key */
    get: operations["ListConfigs"];
    /** Create a config */
    post: operations["CreateConfig"];
  };
  "/keys/{key}/configs/{config}": {
    /** Retrieve config object by name */
    get: operations["RetrieveConfig"];
    /** Updates configuration object */
    post: operations["UpdateConfig"];
    /** Permanently deletes a configuration object. */
    delete: operations["DeleteConfig"];
  };
}

export interface components {
  schemas: {
    /**
     * Postcode
     * @description Correctly formatted postcode. Capitalised and spaced.
     * @example SW1A 2AA
     */
    Postcode: string;
    /**
     * API Key
     * @description Your Ideal Postcodes API Key. Typically beings `ak_`.
     *
     * Available from your dashboard
     *
     * @example ak_hk71kco54zGSGvF9eXXrvvnMOLLNh
     */
    ApiKeyParam: string;
    /**
     * Filter
     * @description Comma separated whitelist of address elements to return.
     *
     * E.g. `filter=line_1,line_2,line_3` returns only `line_1`, `line_2` and `line_3` address elements in your response
     *
     * @example line_1,line_2,line_3
     */
    FilterParam: string;
    /**
     * Page
     * Format: int32
     * @description 0 indexed indicator of the page of results to receive. Virtually all postcode results are returned on page 0.
     *
     * A small number of Multiple Residence postcodes may need pagination (i.e. have more than 100 premises).
     */
    PageParam: number;
    /**
     * Postcode Outward
     * @description The first part of a postcode is known as the outward code. e.g. The outward code of ID1 1QD is ID1. Enables mail to be sorted to the correct local area for delivery. This part of the code contains the area and the district to which the mail is to be delivered, e.g. ‘PO1’, ‘SW1A’ or ‘B23’.
     * @example SW1A
     */
    PostcodeOutward: string;
    /**
     * Postcode Inward
     * @description The second part of a postcode is known as the inward Code. e.g.  The inward code of ID1 1QD is 1QD. This part is one number followed by two letters.  The number identifies the sector in the postal district.  The letters then define one or more properties in that sector.
     * @example 2AA
     */
    PostcodeInward: string;
    /**
     * Post Town
     * @description A Post Town is mandatory for delivery of mail to a Delivery Point. This is not necessarily the nearest town geographically, but a routing instruction to the Royal Mail delivery office sorting mail for that Delivery Point. A Post Town will always be present in every address, and for some Localities the Post Town will be the only locality element present.
     * @example London
     */
    PostTown: string;
    /**
     * Dependant Locality
     * @description When the same thoroughfare name reoccurs in a Post town, it may not be possible to make it dependant on a dependant thoroughfare. In this case the thoroughfare is dependant on a locality. For example if we want to find 1 Back Lane in Huddersfield we see that there are three.
     */
    DependantLocality: string;
    /**
     * Double Dependant Locality
     * @description Used to supplement Dependant Locality. A Double Dependant Locality supplied along with a Dependant Locality if the Dependant Locality exists twice in the same locality.
     */
    DoubleDependantLocality: string;
    /**
     * Thoroughfare
     * @description Also known as the street or road name. In general each Thoroughfare Name will have a separate Postcode. Longer Thoroughfares with high number ranges often have multiple Postcodes covering the entire length of the road, with breaks at suitable points e.g. junctions or natural breaks in the road.
     * @example Downing Street
     */
    Thoroughfare: string;
    /**
     * Dependant Thoroughfare
     * @description Used to supplement thoroughfare. When a thoroughfare name is used twice in the same Post Town, the dependant thoroughfare is added to uniquely indentify a delivery point.
     */
    DependantThoroughfare: string;
    /**
     * Building Number
     * @description Number to identify premise on a thoroughfare or dependant thoroughfare.
     * @example 10
     */
    BuildingNumber: string;
    /**
     * Building Name
     * @description Name of residential or commercial premise. E.g. The Manor, 1-2, A, 12A, K, Victoria House
     */
    BuildingName: string;
    /**
     * Sub-Building Name
     * @description When a premise is split into individual units such as flats, apartments or business units. Cannot be present without either building_name or building_number. E.g. Flat 1, A, 10B
     */
    SubBuildingName: string;
    /**
     * PO Box
     * @description When the PO Box Number field is populated it will contain PO BOX nnnnnn where n represents the PO Box number. Note that the PO Box details can occasionally consist of a combination of numbers and letters. PO Box Numbers are only allocated to Large Users.
     * @example HK860
     */
    POBox: string;
    /**
     * Department Name
     * @description Used to supplment Organisation Name to identify a deparment within the organisation.
     */
    DepartmentName: string;
    /**
     * Organisation Name
     * @description Used to supplment Organisation Name to identify a deparment within the organisation.
     * @example Prime Minister &amp; First Lord Of The Treasury
     */
    OrganisationName: string;
    /**
     * Unique Delivery Point Reference Number (UDPRN)
     * Format: int32
     * @description UDPRN stands for ‘Unique Delivery Point Reference Number’. Royal Mail assigns a unique UDPRN code for each premise on PAF. Simple, unique reference number for each Delivery Point. Unlikely to be reused when an address expires. Up to 8-digit numeric code. A new UDPRN is automatically assigned to each new Delivery Point added to PAF.
     * @example 23747771
     */
    UDPRN: number;
    /**
     * UMPRN
     * @description A small minority of individual premises (as identified by a UDPRN) may have multiple occupants behind the same letterbox. These are known as Multiple Residence occupants and can be queried via the Multiple Residence dataset. Simple, unique reference number for each Multiple Residence occupant. 8-character numeric code. Note: this will be an empty string `""` when not used for legacy reasons
     */
    UMPRN: "" | number;
    /**
     * Postcode Type
     * @description This indicates the type of user. It can only take the values 'S' or 'L' indicating small or large respectively. Large User Postcodes. These are assigned to one single address either due to the large volume of mail received at that address, or because a PO Box or Selectapost service has been set up. Small User Postcodes. These identify a group of Delivery Points. On average there are 15 Delivery Points per Postcode. However this can vary between 1 and, in some cases, 100. There will never be more than 100 Delivery Points on a Postcode.
     * @example S
     * @enum {string}
     */
    PostcodeType: "S" | "L";
    /**
     * Small User Organisation Indicator
     * @description Small User Organisation Indicator can have the values 'Y' or space. A value of 'Y' indicates that a Small User Organisation is present at this address.
     */
    SuOrganisationIndicator: string;
    /**
     * Delivery Point Suffix
     * @description A unique Royal Mail 2-character code (the first numeric & the second alphabetical), which, when added to the Postcode, enables each live Delivery Point to be uniquely identified. Once the Delivery Point is deleted from PAF the DPS may be reused (although they aren’t reused until all remaining Delivery Points in the range have been allocated). The DPS for a Large User is always '1A' as each Large User has its own Postcode. E.g. 2B
     * @example 1A
     */
    DeliveryPointSuffix: string;
    /**
     * Line 1
     * @description First Address Line. Often contains premise and thoroughfare information. In the case of a commercial premise, the first line is always the full name of the registered organisation. Never empty.
     * @example Prime Minister &amp; First Lord of Treasury
     */
    Line1: string;
    /**
     * Line 2
     * @description Second Address Line. Often contains thoroughfare and locality information. May be empty.
     * @example 10 Downing Street
     */
    Line2: string;
    /**
     * Line 3
     * @description Third address line. May be empty.
     */
    Line3: string;
    /**
     * Premise
     * @description A pre-computed string which sensibly combines building_number, building_name and sub_building_name. building_number, building_name and sub_building_name represent raw data from Royal Mail's and can be difficult to parse if you are unaware of how the Postcode Address File premise fields work together. For this reason, we also provide a pre-computed premise field which intelligently gathers these points into a single, simple premise string. This field is ideal if you want to pull premise information and thoroughfare information separately instead of using our address lines data.
     * @example 10
     */
    Premise: string;
    /**
     * Country
     * @description The country for which the postcode belongs to. May be empty for a small number of addresses. Data source: ONS
     * @example England
     */
    Country: string;
    /**
     * County
     * @description Since postal, administrative or traditional counties may not apply to some addresses, the county field is designed to return whatever county data is available. Normally, the postal county is returned. If this is not present, the county field will fall back to the administrative county. If the administrative county is also not present, the county field will fall back to the traditional county. May be empty in cases where no administrative, postal or traditional county present.
     * @example London
     */
    County: string;
    /**
     * Administrative County
     * @description The current administrative county to which the postcode has been assigned. A Unitary Authority name, where one is present. If there is no Unitary Authority, the County name is used. This information is not static, because County boundaries may change due to administrative changes. Data source: ONS. May be empty.
     */
    AdministrativeCounty: string;
    /**
     * Postal County
     * @description Postal counties were used for the distribution of mail before the Postcode system was introduced in the 1970s. The Former Postal County was the Administrative County at the time. This data rarely changes. Data source: Royal Mail. May be empty.
     * @example London
     */
    PostalCounty: string;
    /**
     * Traditional County
     * @description Traditional counties are provided by the Association of British Counties. It’s historical data, and can date from the 1800s. Data source: Royal Mail. May be empty.
     * @example Greater London
     */
    TraditionalCounty: string;
    /**
     * District
     * @description The current district/unitary authority to which the postcode has been assigned. Data source: ONS
     * @example Westminster
     */
    District: string;
    /**
     * Ward
     * @description The current administrative/electoral area to which the postcode has been assigned. May be empty for a small number of addresses. Data source: ONS
     * @example St. James'
     */
    Ward: string;
    /**
     * Longitude
     * @description The longitude of the postcode (WGS84/ETRS89). Accurate at the postcode level Can be a positive or negative decimal. E.g. -0.1283983 Returns an empty string if no location data is available.  Otherwise, a number is returned
     */
    Longitude: "" | number;
    /**
     * Longitude
     * @description The latitude of the postcode (WGS84/ETRS89). Accurate at the postcode level Can be a positive or negative decimal. E.g. 51.5083983 Returns an empty string if no location data is available.  Otherwise a number is returned.
     */
    Latitude: "" | number;
    /**
     * Eastings
     * @description Eastings reference using the [Ordnance Survey National Grid reference system](https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid) Northern Ireland Eastings uses the [Irish Grid Reference System](https://en.wikipedia.org/wiki/Irish_grid_reference_system) Metres from origin. E.g. 550458 Returns an empty string if no location data is available. Otherwise a number is returned
     */
    Eastings: "" | number;
    /**
     * Eastings
     * @description Northings reference using the [Ordnance Survey National Grid reference system](https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid) Northern Ireland Northings uses the [Irish Grid Reference System](https://en.wikipedia.org/wiki/Irish_grid_reference_system) Metres from origin. E.g. 180458 Returns an empty string if no location data is available. Otherwise a number is returned
     */
    Northings: "" | number;
    /**
     * Unique Delivery Point Reference Number (UDPRN)
     * @description UPRN stands for Unique Property Reference Number and is maintained by the Ordnance Survey (OS). Local governments in the UK have allocated a unique number for each land or property. See our UPRN guide for more information. Up to 12 digits in length. Multiple Residence premises currently share the same UPRN as the parent premise. May not be available for a small number of Great Britain addresses due to longer update cycles for Ordnance Survey's AddressBase datasets. Returns empty string "" in these instances. Although UPRN takes an integer format, we encode and transmit this data as strings. As a 12 digit number, the UPRN can exceed the maximum safe integer (Number.MAX_SAFE_INTEGER) in most browsers causing this datapoint to be corrupted. Take special care when storing UPRN. As a 12 digit identifier, you will need 64 bits to encode every possible UPRN value.
     */
    UPRN: string;
    /**
     * ID
     * @description Global unique internally generated identifier for an address.
     * @example paf_8387729
     */
    ID: string;
    /**
     * Dataset
     * @description Indicates the provenance of an address
     * @enum {string}
     */
    Dataset: "paf" | "mr" | "nyb" | "usps";
    /**
     * ISO Country Code
     * @description 3 letter ISO country code
     * @enum {string}
     */
    CountryISO: "GBR" | "IMN" | "JEY" | "GGY" | "USA" | "PRI" | "GUM";
    /**
     * Postcode Address File Address
     * @description Standard UK Address.
     */
    PafAddress: {
      postcode: components["schemas"]["Postcode"];
      postcode_outward: components["schemas"]["PostcodeOutward"];
      postcode_inward: components["schemas"]["PostcodeInward"];
      post_town: components["schemas"]["PostTown"];
      dependant_locality: components["schemas"]["DependantLocality"];
      double_dependant_locality: components["schemas"]["DoubleDependantLocality"];
      thoroughfare: components["schemas"]["Thoroughfare"];
      dependant_thoroughfare: components["schemas"]["DependantThoroughfare"];
      building_number: components["schemas"]["BuildingNumber"];
      building_name: components["schemas"]["BuildingName"];
      sub_building_name: components["schemas"]["SubBuildingName"];
      po_box: components["schemas"]["POBox"];
      department_name: components["schemas"]["DepartmentName"];
      organisation_name: components["schemas"]["OrganisationName"];
      udprn: components["schemas"]["UDPRN"];
      umprn: components["schemas"]["UMPRN"];
      postcode_type: components["schemas"]["PostcodeType"];
      su_organisation_indicator: components["schemas"]["SuOrganisationIndicator"];
      delivery_point_suffix: components["schemas"]["DeliveryPointSuffix"];
      line_1: components["schemas"]["Line1"];
      line_2: components["schemas"]["Line2"];
      line_3: components["schemas"]["Line3"];
      premise: components["schemas"]["Premise"];
      country: components["schemas"]["Country"];
      county: components["schemas"]["County"];
      administrative_county: components["schemas"]["AdministrativeCounty"];
      postal_county: components["schemas"]["PostalCounty"];
      traditional_county: components["schemas"]["TraditionalCounty"];
      district: components["schemas"]["District"];
      ward: components["schemas"]["Ward"];
      longitude: components["schemas"]["Longitude"];
      latitude: components["schemas"]["Latitude"];
      eastings: components["schemas"]["Eastings"];
      northings: components["schemas"]["Northings"];
      uprn: components["schemas"]["UPRN"];
      id: components["schemas"]["ID"];
      /** @enum {undefined} */
      dataset: components["schemas"]["Dataset"];
      /** @enum {undefined} */
      country_iso: components["schemas"]["CountryISO"];
    };
    /**
     * Multiple Residence Address
     * @description Subdivision of a Postcode Address File address. Does not have its own delivery point.
     */
    MrAddress: components["schemas"]["PafAddress"] & {
      /** @enum {undefined} */
      dataset?: components["schemas"]["Dataset"];
    };
    /**
     * Not Yet Built Address
     * @description UK premise under construction
     */
    NybAddress: components["schemas"]["PafAddress"] & {
      /** @enum {undefined} */
      dataset?: components["schemas"]["Dataset"];
    };
    /** Postcode Response */
    PostcodeResponse: {
      /** @description All addresses listed at the postcode */
      result: (
        | components["schemas"]["PafAddress"]
        | components["schemas"]["MrAddress"]
        | components["schemas"]["NybAddress"]
      )[];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** Postcode Not Found */
    PostcodeNotFoundResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 4040;
      /** @enum {string} */
      message: "Postcode not found";
      /** @description A list of alternate nearest matching postcodes you can try */
      suggestions: string[];
    };
    /** UDPRN Response */
    UDPRNResponse: {
      result:
        | components["schemas"]["PafAddress"]
        | components["schemas"]["NybAddress"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** Basic Error Response */
    ErrorResponse: {
      /**
       * Format: int32
       * @description API Response Code. Non `2xxx` code indicates a failure. This code will provide a more specific reason when a failure occurs and facilitates debugging.
       */
      code: number;
      /** @description Human readable error message supplied with every error response. */
      message: string;
    };
    /** UDPRN Response */
    UMPRNResponse: {
      result: components["schemas"]["MrAddress"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** Key */
    ApiKey: {
      /**
       * @description Determines whether the key can be used by the requesting agent.
       *
       * Returns false if one of the following conditions are met:
       *   - Key has no lookups remaining
       *   - Daily limit has been reached on the key
       *   - Daily individual limit has been reached
       *   - Key is not being used via an authorised URL
       *   - (Sublicensed key only) Key has a valid licensee attached
       *   - (Sublicensed key only) Key is not being used via an authorised URL specified by licensee
       *
       * @example true
       */
      available: boolean;
    };
    /** API Key Response */
    ApiKeyResponse: {
      result: components["schemas"]["ApiKey"];
      /** @enum {string} */
      message: "Success";
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
    };
    /**
     * User Token
     * @description A secret key used for sensitive operations on your account and API Keys.
     *
     * Your user token can be retrieved and managed from your [accounts page](https://ideal-postcodes.co.uk/account).
     *
     * Typically beings `uk_...`
     *
     * @example uk_B59ScW1p1HHouf1VqclEPZUx
     */
    UserTokenParam: string;
    /** API Key Daily Limit */
    ApiKeyDailyLimit: {
      /**
       * Format: int32
       * @description `number` or `null`. The daily lookup limit currently set on your key.
       * `null` means the limit is currently disabled.
       * @example 1000
       */
      limit: number;
      /**
       * Format: int32
       * @description Number of lookups performed today which count towards your daily limit.
       * @example 288
       */
      consumed: number;
    };
    /** API Key Individual Limit */
    ApiKeyIndividualLimit: {
      /**
       * Format: int32
       * @description `number` or `null` Limit set on the number of lookups that can be
       * performed from a single IP address. `null` means the limit is currently
       * disabled.
       * @example 30
       */
      limit: number;
    };
    /** API Key Notifications */
    ApiKeyNotifications: {
      /** @description A list of email addresses designated by you to receive notifications about this key. */
      emails: string[];
      /** @description Indicates whether email notifications are enabled. */
      enabled: boolean;
    };
    /**
     * API Key Dataset Availability
     * @description Indicates which datasets are available and added by default to the address responses
     */
    ApiKeyDatasets: {
      /**
       * @description UK Postcode Address File enabled
       * @example true
       */
      paf: boolean;
      /**
       * @description UK Multiple Residence Dataset enabled
       * @example true
       */
      mr: boolean;
      /** @description UK Not Yet Built Dataset enabled */
      nyb: boolean;
    };
    /**
     * API Key Automated Topup
     * @description Automated topup status
     */
    ApiKeyAutomatedTopup: {
      /**
       * @description Indicates whether automated top-ups are enabled
       * @example true
       */
      enabled: boolean;
    };
    /** API Key Batch Purchase */
    ApiKeyCurrentPurchase: {
      /**
       * @description `string` or `null` The date when this purchase will expire in simplified
       * extended ISO format (ISO 8601). This is typically 365 days from the time
       * of first use. This field will be `null` if the purchase has not yet been
       * used.
       * @example 2022-01-06T11:41:27.092Z
       */
      expires: string;
      /**
       * Format: int32
       * @description Number of procured lookups from this purchase.
       * @example 20000
       */
      purchased: number;
      /**
       * Format: int32
       * @description Number of consumed lookups off this purchase.
       * @example 121
       */
      consumed: number;
    };
    /** API Key Details */
    ApiKeyDetails: {
      /**
       * Format: int32
       * @example 19889
       */
      lookups_remaining: number;
      daily_limit: components["schemas"]["ApiKeyDailyLimit"];
      individual_limit: components["schemas"]["ApiKeyIndividualLimit"];
      /** @description A list of allowed URLs. An empty list means that allowed URLs are disabled. */
      allowed_urls: string[];
      notifications?: components["schemas"]["ApiKeyNotifications"];
      datasets?: components["schemas"]["ApiKeyDatasets"];
      automated_topups: components["schemas"]["ApiKeyAutomatedTopup"];
      /** @description Current balance purchases attached to key. */
      current_purchases: components["schemas"]["ApiKeyCurrentPurchase"][];
    } & {
      notificatinos: unknown;
    };
    /** API Key Details Response */
    ApiKeyDetailsResponse: {
      result: components["schemas"]["ApiKeyDetails"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Start Time
     * Format: int32
     * @description A start date/time in the form of a UNIX Timestamp in milliseconds, e.g.  `1418556452651`.
     *
     * @example 1418556452651
     */
    StartParam: number;
    /**
     * End Time
     * Format: int32
     * @description An start date/time in the form of a UNIX Timestamp in milliseconds, e.g.  `1418556477882`.
     *
     * @example 1418556477882
     */
    EndParam: number;
    /**
     * Tags
     * @description A comma separated list of tags to query over.
     *
     * Useful if you want to specify the circumstances in which the request was made.
     *
     * If multiple tags are specified, the response will only comprise of requests for which all the tags are satisfied - i.e. searching `"foo,bar"` will only query requests which tagged both `"foo"` and `"bar"`.
     *
     * @example foo,bar
     */
    TagsParam: string;
    /**
     * Licensee Key
     * @description Uniquely identifies a licensee
     *
     * @example sk_hk71kco54zGSGvF9eXXrvvnMOLLNh
     */
    LicenseeParam: string;
    /** Key Usage */
    KeyUsageResult: {
      /**
       * @description Start date in ISO 8601 format.
       * @example 2015-01-22T15:08:06.609Z
       */
      start: string;
      /**
       * @description End date in ISO 8601 format.
       * @example 2015-01-23T15:08:06.609Z
       */
      end: string;
      /**
       * Format: int32
       * @description Total of paid lookups performed in specified period.
       * @example 132
       */
      total: number;
      /** @description An array of objects representing number of paid lookups made on specific days, ordered by date. Each object contains a `date` attribute, which represents the day and a `count` attribute, which represents the number of paid lookups made on that day. */
      dailyCount: {
        /** @example 2015-01-22T00:00:00.000Z */
        date: string;
        /**
         * Format: int32
         * @example 132
         */
        count: number;
      }[];
    };
    /** Key Usage Response */
    ApiKeyUsageResponse: {
      result: components["schemas"]["KeyUsageResult"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Context
     * @description Limits search results within a geographical boundary or country.
     * @enum {string}
     */
    Context: "gbr" | "usa";
    /**
     * Limit
     * Format: int32
     * @description Specifies the maximum number of suggestions to retrieve.
     *
     * By default the limit is 10, unless a postcode is queried (then all addresses at that postcode will be returned). Limit can be shortened to `l=`
     *
     * @default 10
     * @example 5
     */
    LimitParam: number;
    /**
     * Postcode Outward
     * @description Filter by outward code.
     * @example 1AA
     */
    PostcodeOutwardParam: string;
    /**
     * Postcode
     * @description Filter by postcode. Can be combined with query to perform a postcode + building number/name search.
     * @example SW1A 2AA
     */
    PostcodeParam: string;
    /**
     * Postcode Area
     * @description Filter by postcode. Can be combined with query to perform a postcode + building number/name search.
     * @example SW
     */
    PostcodeAreaParam: string;
    /**
     * Postcode Sector
     * @description Filter by postcode sector, the outward code plus first numeric of the inward code.
     * @example SW1A 2
     */
    PostcodeSectorParam: string;
    /**
     * Post Town
     * @description Filter by town.
     * @example London
     */
    PostTownParam: string;
    /**
     * UPRN
     * @description Filters by UPRN. Does not accept comma separated terms. Only a single term is permitted
     * @example 100023336956
     */
    UPRNParam: number;
    /**
     * Country
     * @description Filter by country. Possible values are England, Scotland, Wales, Northern Ireland, Jersey, Guernsey and Isle of Man.
     * @example England
     */
    CountryParam: string;
    /**
     * Country
     * @description Filter by Postcode Type. Useful for separating organisational and residential addresses
     * @example L
     */
    PostcodeTypeParam: string;
    /**
     * SU Organisation Indicator
     * @description Filter by Organisation Indicator. Useful for separating organisational and residential addresses
     * @example Y
     */
    SmallUserParam: string;
    /**
     * Box
     * @description Restrict search to a geospatial box determined by the "top-left" and "bottom-right" gelocations.   Only one geospatial box can be provided.
     * @example 2.095,57.15,-2.096,57.14
     */
    BoxParam: string;
    /**
     * Bias Postcode Outward
     * @description Bias by outward code
     */
    BiasPostcodeOutwardParam: string;
    /**
     * Bias Postcode
     * @description Bias by postcode. Can be combined with query to perform a postcode + building number/name search.
     * @example /addresses?postcode=SW1A2AA&q=10
     */
    BiasPostcodeParam: string;
    /**
     * Bias Postcode Area
     * @description Bias by postcode area, the first one or two non-numeric characters of a postcode.
     * @example The postcode area of SW1A 2AA and N1 6RT are SW and N respectively
     */
    BiasPostcodeAreaParam: string;
    /**
     * Bias Postcode Sector
     * @description Bias by postcode sector, the outward code plus first numeric of the inward code.
     * @example SW1A 2AA is SW1A 2
     */
    BiasPostcodeSectorParam: string;
    /**
     * Bias Post Town
     * @description Bias by town.
     */
    BiasPosttownParam: string;
    /**
     * Bias Thoroughfare
     * @description Bias by street name.
     */
    BiasThoroughfareParam: string;
    /**
     * Bias County
     * @description Bias by country. Possible values are England, Scotland, Wales, Northern Ireland, Jersey, Guernsey and Isle of Man.
     */
    BiasCountryParam: string;
    /**
     * Bias Lon/Lat
     * @description Bias search to a geospatial circle determined by an origin and radius in meters. Max radius is `50000`.  Uses the format bias_lonlat=[longitude],[latitude],[radius in metres] Only one geospatial bias may be provided
     * @example -2.095,57.15,100
     */
    BiasLonLatParam: string;
    /**
     * Bias query by Geolocation of IP
     * @description Biases search based on approximate geolocation of IP address.
     * Set `bias_ip=true` to enable.
     * @example bias_ip=true
     * @enum {string}
     */
    BiasIpParam: "true";
    /**
     * UK Postcode Address File Address Autocompletion Hit
     * @description Represents an address suggestion from the UK Postcode Address File.
     */
    PafSuggestion: {
      id: components["schemas"]["ID"];
      /**
       * @description Address suggestion for your given query.
       * @example Flat 6, 12 Roskear, Camborne, TR14
       */
      suggestion: string;
      udprn: components["schemas"]["UDPRN"];
      urls: {
        /**
         * @description URL to retrieve the entire details for a given address suggestion by the UDPRN
         * @example /v1/udprn/50985827
         */
        udprn: string;
      };
    };
    /** Multiple Residence Address Autocompletion Hit */
    MrSuggestion: {
      id: components["schemas"]["ID"];
      /**
       * @description Address suggestion for your given query.
       * @example Flat 6, 12 Roskear, Camborne, TR14
       */
      suggestion: string;
      udprn: components["schemas"]["UDPRN"];
      /**
       * Format: int32
       * @description Optionally returned field, representing the UMPRN of a Multiple Residence household
       * @example 51103417
       */
      umprn: number;
      urls: {
        /**
         * @description URL to retrieve the entire details for a given address suggestion by the UDPRN
         * @example /v1/udprn/50985827
         */
        udprn: string;
        /**
         * @description Optionally returned field, to retrieve the entire details for a suggested Multiple Residence household
         * @example /v1/umprn/51103417
         */
        umprn: string;
      };
    };
    /** Not Yet Built Address Autocompletion Hit */
    NybSuggestion: components["schemas"]["PafSuggestion"];
    /**
     * Global Address Autocompletion Suggestion
     * @description Represents an address suggestion for any address in the world
     */
    GlobalAddressSuggestion: {
      id: components["schemas"]["ID"];
      /**
       * @description Address Suggestion to be displayed to the user
       * @example Flat 6, 12 Roskear, Camborne, TR14
       */
      suggestion: string;
      urls: {
        /**
         * @description URL to retrieve the entire details for a given address suggestion by the UDPRN
         * @example /v1/udprn/50985827
         */
        id?: string;
      };
    };
    /** Address Autocomplete Response */
    AutocompleteResponse: {
      result: {
        hits: (
          | components["schemas"]["PafSuggestion"]
          | components["schemas"]["MrSuggestion"]
          | components["schemas"]["NybSuggestion"]
          | components["schemas"]["GlobalAddressSuggestion"]
        )[];
      };
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Global Address
     * @description Global (non-UK) address in the UK address format
     */
    GbrGlobalAddress: {
      /** @description Postal or Zip Code */
      postcode: string;
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postcode_outward: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postcode_inward: "";
      /** @description Town or City */
      post_town: string;
      dependant_locality: components["schemas"]["DependantLocality"];
      double_dependant_locality: components["schemas"]["DoubleDependantLocality"];
      thoroughfare: components["schemas"]["Thoroughfare"];
      dependant_thoroughfare: components["schemas"]["DependantThoroughfare"];
      building_number: components["schemas"]["BuildingNumber"];
      building_name: components["schemas"]["BuildingName"];
      sub_building_name: components["schemas"]["SubBuildingName"];
      /** @description PO Box */
      po_box: string;
      /** @description Department name at premise */
      department_name: string;
      /** @description Name of organisation at premise */
      organisation_name: string;
      /**
       * @description Not available for non-UK addresses. See id for address identifier
       * @enum {string}
       */
      udprn: "";
      /**
       * @description Not available for non-UK addresses. See id for address identifier
       * @enum {string}
       */
      umprn: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postcode_type: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      su_organisation_indicator: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      delivery_point_suffix: "";
      line_1: components["schemas"]["Line1"];
      line_2: components["schemas"]["Line2"];
      line_3: components["schemas"]["Line3"];
      premise: components["schemas"]["Premise"];
      country: components["schemas"]["Country"];
      /** @description Province, state or county */
      county: string;
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      administrative_county: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      postal_county: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      traditional_county: "";
      district: components["schemas"]["District"];
      ward: components["schemas"]["Ward"];
      longitude: components["schemas"]["Longitude"];
      latitude: components["schemas"]["Latitude"];
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      eastings: "";
      /**
       * @description Not available for non-UK addresses
       * @enum {string}
       */
      northings: "";
      /**
       * @description Not available for non-UK addresses. See id for address identifier
       * @enum {string}
       */
      uprn: "";
      id: components["schemas"]["ID"];
      dataset: components["schemas"]["Dataset"];
      country_iso: components["schemas"]["CountryISO"];
    };
    /** Address Resolution Response (GBR) */
    GbrResolveAddressResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
      result:
        | components["schemas"]["PafAddress"]
        | components["schemas"]["MrAddress"]
        | components["schemas"]["NybAddress"]
        | components["schemas"]["GbrGlobalAddress"];
    };
    /** Address Search Response */
    AddressResponse: {
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
      result: {
        /** @description List of matching addresses */
        hits: (
          | components["schemas"]["PafAddress"]
          | components["schemas"]["MrAddress"]
          | components["schemas"]["NybAddress"]
        )[];
        /** Format: int32 */
        total: number;
        /**
         * Format: int32
         * @default 10
         * @example 10
         */
        limit: number;
        /** Format: int32 */
        page: number;
      };
    };
    /**
     * Licensee
     * @description Licensee object which can be defined by user
     */
    LicenseeEditable: {
      /**
       * @description Licensee individual or organisation name
       * @example Qwerty Widgets Limited
       */
      name?: string;
      /**
       * @description Licensee's first, second and third line address as well as post town concatenated by commas
       * @example 12 High Street, Manchester
       */
      address?: string;
      /**
       * @description Licensee's postcode
       * @example ID1 1QD
       */
      postcode?: string;
      /** @description A list of allowed URLs. An empty list means that whitelisting is disabled */
      whitelist?: string[];
      daily?: {
        /**
         * Format: int32
         * @description The maximum number of lookups this licensee can perform in a day. `null` indicates the limit is not active
         * @example 10000
         */
        limit?: number;
      };
    };
    /** Licensee */
    Licensee: components["schemas"]["LicenseeEditable"] &
      ({
        /**
         * @description An immutable ID provided for every licensee. Primarily used for paginated list requests.
         *
         * @example 56a11209ebe230380bf104c3
         */
        id: string;
        /**
         * @description Uniquely identifies a licensee for a key.
         *
         * Required to perform paid lookups for a specific licensee. Typically begins `sk_`.
         *
         * @example sl_ijoiqsxeQgXW2gkiE0X94
         */
        key: string;
        /**
         * @description Timestamp for when the licensee was created
         * @example 2016-01-21T17:14:49.971Z
         */
        createdAt: string;
        daily: {
          /**
           * Format: int32
           * @description The number lookups performed by the licensee on the day represented b `licesees.daily.updatedAt`
           * @example 232
           */
          count: number;
          /**
           * @description The timestamp when the limit was last used.
           * @example 2016-08-05T16:43:28.865Z
           */
          updatedAt: string;
        };
      } & {
        name: unknown;
        address: unknown;
        postcode: unknown;
        whitelist: unknown;
      });
    /** Licensee List Response */
    LicenseesResponse: {
      /** @description List of licensees */
      result: {
        licensees?: components["schemas"]["Licensee"][];
        /** @description Returns true if there are more licensees listed after the maximum number of results as implied by `limit` */
        hasMore?: boolean;
      };
      /** @enum {string} */
      message: "Success";
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
    };
    /** Licensee Response */
    LicenseeResponse: {
      result: components["schemas"]["Licensee"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /** Config Object */
    Config: {
      /**
       * @description Timestamp for when the config was created
       * @example 2016-01-21T17:14:49.971Z
       */
      updatedAt: string;
      /**
       * @description Timestamp for when the config was updated
       * @example 2016-01-21T17:14:49.971Z
       */
      createdAt: string;
      /**
       * @description A unique name to identify the configuration payload
       * @example woocommerce
       */
      name: string;
      /**
       * @description A serialised payload of up to `4096` characters
       * @example {
       *   "removeOrganisation": false
       * }
       */
      payload: string;
    };
    /** Config List Response */
    ConfigsResponse: {
      /** @description List of configurations */
      result: {
        configs: components["schemas"]["Config"][];
      };
      /** @enum {string} */
      message: "Success";
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
    };
    /** Bad Request Error Response */
    BadRequestResponse: components["schemas"]["ErrorResponse"] & {
      /**
       * Format: int32
       * @description `400X` type error response code
       */
      code: number;
      /** @description Bad request error description */
      message: string;
      errors?: {
        /**
         * @description Indicates location of error in request query or URL parameter
         * @example should have required property 'type'
         */
        message: string;
        /**
         * @description Indicates location of error in request query or URL parameter
         * @example .query.type
         */
        path: string;
        /** @example required.openapi.validation */
        errorCode?: string;
      }[];
    };
    /** Unauthorized Request Error Response */
    UnauthorizedResponse: components["schemas"]["ErrorResponse"] & {
      /**
       * Format: int32
       * @description `401X` type error response code
       */
      code: number;
      /** @description Unauthorized request error description */
      message: string;
    };
    /**
     * New Config Object
     * @description Required configuration object parameters
     */
    ConfigNewParam: {
      /**
       * @description A unique name to identify the configuration payload
       * @example woocommerce
       */
      name: string;
      /**
       * @description A serialised payload of up to `4096` characters
       * @example {
       *   "removeOrganisation": false
       * }
       */
      payload: string;
    };
    /** Config Response */
    ConfigResponse: {
      result: components["schemas"]["Config"];
      /**
       * Format: int32
       * @enum {integer}
       */
      code: 2000;
      /** @enum {string} */
      message: "Success";
    };
    /**
     * Configuration Name
     * @description User provided configuration object name
     * @example idpc-be
     */
    ConfigParam: string;
    /** Not Found Response */
    NotFoundResponse: components["schemas"]["ErrorResponse"] & {
      /**
       * Format: int32
       * @description `404X` type error response code
       */
      code: number;
      /** @description Resource not found error description */
      message: string;
    };
    /**
     * Update Config Object
     * @description Config object update parameters
     */
    ConfigUpdateParam: {
      /**
       * @description A serialised payload of up to `4096` characters
       * @example {
       *   "removeOrganisation": false
       * }
       */
      payload?: string;
    };
  };
}

export interface operations {
  /**
   * Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
   *
   * The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
   *
   * ## JavaScript Example
   *
   * ```javascript
   * const { Client, postcodes } = require("@ideal-postcodes/core-node");
   *
   * const api_key = "iddqd";
   *
   * const client = new Client({ api_key: "iddqd" });
   *
   * await postcodes.retrieve(client, "ID1 1QD", { query: { api_key } });
   * ```
   *
   * This API models postcodes as a HTTP resource. The above example provides a thin JavaScript abstraction and more control over the HTTP request and response. The JavaScript client also provides a number of terser helper methods like [`client.lookupPostcode`](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
   *
   * If you wish to quickly add Postcode Lookup driven address finder on your page, see our [Postcode Lookup plugin](/postcode-lookup) and [associated demos](/postcode-lookup-demo).
   *
   * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
   *
   * ## Postcode Not Found
   *
   * Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
   *
   * ```json
   * {
   *   "code": 4040,
   *   "message": "Postcode not found",
   *   "suggestions": ["SW1A 0AA"]
   * }
   * ```
   *
   * ### Suggestions
   *
   * If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
   *
   * If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
   *
   * The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
   *
   * ## Multiple Residence
   *
   * A small number of  postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
   *
   * ```javascript
   * const { lookupPostcode, Client } = require("@ideal-postcodes/core-node");
   *
   * const client = new Client({ api_key: "iddqdmr" });
   *
   * await lookupPostcode({ client, postcode: "CV4 7AL", page: 1 });
   * ```
   *
   * ## Testing
   *
   * We have a range of test postcodes that yield both successful and unsuccessful responses to your request. They are the following
   *
   * - `ID1 1QD` Returns a successful Postcode Lookup response `2000`
   * - `ID1 KFA` Returns "postcode not found", error `4040`
   * - `ID1 CLIP` Returns "no lookups remaining", error `4020`
   * - `ID1 CHOP` Returns "daily (or individual) lookup limit breached", error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  Postcodes: {
    parameters: {
      path: {
        /** Postcode to retrieve */
        postcode: components["schemas"]["Postcode"];
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
        page?: components["schemas"]["PageParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["PostcodeResponse"];
        };
      };
      /** Postcode Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["PostcodeNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
   *
   * You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
   *
   * UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
   *
   * ## Testing
   *
   * To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
   *
   * They are the following:
   *
   * - `0` Returns a successful UDPRN lookup response
   *   `2000`
   * - `-1` Returns "UDPRN not found", error `4044`
   * - `-2` Returns "no lookups remaining", error `4020`
   * - `-3` Returns "daily (or individual) lookup limit breached",
   *   error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  UDPRN: {
    parameters: {
      path: {
        /** UDPRN to be retrieved */
        udprn: string;
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UDPRNResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
   *
   * UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
   *
   * ## Testing
   *
   * To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
   *
   * - `0` Returns a successful UMPRN lookup response `2000`
   * - `-1` Returns "UMPRN not found", error `4044`
   * - `-2` Returns "no lookups remaining", error `4020`
   * - `-3` Returns "daily (or individual) lookup limit breached", error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   *
   * ### Pricing
   *
   * Per lookup charges apply. Empty responses are not charged.
   */
  UMPRN: {
    parameters: {
      path: {
        /** UMPRN to be retrieved */
        umprn: string;
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UMPRNResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns public information on key. Currently only returns whether the key is currently useable via the `available` property. Use this to discover if the key is useable before making further requests.
   *
   * You may pass both API Keys (beginning `ak_`) and Sub-licensed Keys (beginning `sl_`).
   * ## Testing
   *
   * To test your implementation of our API, you may use the following test keys.
   *
   * - **iddqd** Availability will return as `true`
   * - **idkfa** Availability will return as `false`
   */
  KeyAvailability: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyResponse"];
        };
      };
      /** Invalid Key */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Returns private data on the key including remaining lookups, available datasets and usage limits. */
  KeyDetails: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyDetailsResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Reports the number of lookups consumed on a key for a range of days.
   *
   * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
   */
  KeyUsage: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** A start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time. */
        start?: components["schemas"]["StartParam"];
        /** An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used. */
        end?: components["schemas"]["EndParam"];
        tags?: components["schemas"]["TagsParam"];
        /** Sublicensed keys only. This will restrict the analysed dataset to a specific licensee. */
        licensee?: components["schemas"]["LicenseeParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyUsageResponse"];
        };
      };
    };
  };
  /**
   * Reports lookup information on a key for paid lookups.
   *
   * This method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).
   *
   * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
   *
   * ## Download Usage History (CSV)
   *
   * `GET /keys/:key/lookups`
   *
   * Returns a CSV download of lookups performed and associated information.
   *
   * Note that the Content-Type returned will be CSV (text/csv). For a non 200 response, the `Content-Type` will revert to JSON with the error code and message embedded.
   *
   * ## Data Redaction
   *
   * Personally Identifiable Data (PII) caught in this your usage log (including IP, search term and URL data) will be redacted on a weekly basis.
   *
   * By default, PII will be redacted if it is older than 21 days. This timeframe can be configured from your dashboard.
   *
   * You may prevent PII collection altogether by setting the interval to `0` days.
   */
  KeyLogs: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** An start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time. */
        start?: components["schemas"]["StartParam"];
        /** An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used. */
        end?: components["schemas"]["EndParam"];
        /** Sublicensed keys only. This will restrict the analysed dataset to a specific licensee. */
        licensee?: components["schemas"]["LicenseeParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "text/csv": string;
        };
      };
    };
  };
  /**
   * The address autocomplete API returns a list of address suggestions that match the query ordered by relevance score.
   *
   * This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
   *
   * If you wish to quickly add address autocompletion to your address forms, see [Address Finder](/address-finder) and [associated demos](/address-finder-demo).
   *
   * ## Implementing Address Autocomplete
   *
   * Retrieving addresses using Address Autocomplete is a 2 step process.
   *
   * 1. Retrieve partial address suggestions via `/autocomplete/addresses`
   * 2. Retrieve the entire address by following the URL provided by the suggestion
   *
   * Step 2 will decrement your lookup balance.
   *
   * Please note, this API is not intended to be a free standalone resource.
   *
   * ### JavaScript Example
   *
   * #### Step 1. Retrieve a list of suggestions
   *
   * ```javascript
   * const { Client, autocomplete } = require("@ideal-postcodes/core-node");
   *
   * const response = await autocomplete.list(client, {
   *   query: {
   *     query: "221b bake",
   *     api_key: "iddqd",
   *   },
   * });
   * ```
   *
   * #### Step 2. Resolve a suggestion retrieved above for a full address
   *
   * ```javascript
   * const { lookupUdprn } = require("@ideal-postcodes/core-node");
   *
   * const udprn = 17646242;
   *
   * await lookupUdprn({ client, udprn });
   * ```
   *
   * ## Filters
   *
   * You can strictly narrow your result by adding filters to your querystring which correspond with an address attribute.
   *
   * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
   *
   * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
   *
   * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are <code>OR</code>'ed, i.e. the matching result sets are combined.
   *
   * All filters can accept multiple terms unless stated otherwise below.
   *
   * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are <code>AND</code>'ed, i.e. each additional filter narrows the result set.
   *
   * A maximum of **10** terms are allowed across all filters.
   *
   * ## Biases
   *
   * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
   *
   * Biased searches, unlike filtered searches, also allow unmatched addresses to appear. These will rank lower.
   *
   * For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
   *
   * No bias effect applies to bias terms that are invalid.
   * e.g. `bias_postcode=SW1A2AAA`
   *
   * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
   *
   * All biases can accept multiple terms unless stated otherwise below.
   *
   * A combined maximum of **5** terms are allowed across all biases.
   *
   * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
   *
   * ## Suggestion Format
   *
   * The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
   *
   * ## Querying with a Postcode
   *
   * - If a postcode is passed as a query, all addresses for that postcode will be listed as the result if the limit parameter is not supplied
   * - If a postcode forms only part of the query, your autocomplete results will be filtered by that postcode
   *
   * ## Querying Multiple Residence
   *
   * For Multiple Residence enabled keys, any Multiple Residence households will also return a UMPRN id. This can be retrieved with the `/umprn/:id` endpoint.
   * Note that Multiple Residence households will always have:
   * - A parent premise with a UDPRN
   * - A single UDPRN premise may have many Multiple Residence households with different UMPRNs.
   *
   * ## Rate Limiting
   *
   * You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
   *
   * | Header                  | Description                                                                            |
   * | ----------------------- | -------------------------------------------------------------------------------------- |
   * | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
   * | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
   * | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
   *
   * ## Pricing
   *
   * This API currently does not affect your balance. However, subsequent searches require a paid request (e.g. a UDPRN search). This paid request, will yield the complete address.
   *
   * Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
   *
   * ## Testing
   *
   * `ID1 1QD` will return address suggestions, that when retrieved via `/udprn/:id` will not affect your balance.
   */
  AddressAutocomplete: {
    parameters: {
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        /** Specifies the address you wish to query. Query can be shortened to `q=` */
        query?: string;
        context?: components["schemas"]["Context"];
        /** Limits number of address suggestions unless a postcode is detected. In this instance entire list of addreses for that postcode is returned. */
        limit?: components["schemas"]["LimitParam"];
        postcode_outward?: components["schemas"]["PostcodeOutwardParam"];
        postcode?: components["schemas"]["PostcodeParam"];
        postcode_area?: components["schemas"]["PostcodeAreaParam"];
        postcode_sector?: components["schemas"]["PostcodeSectorParam"];
        post_town?: components["schemas"]["PostTownParam"];
        uprn?: components["schemas"]["UPRNParam"];
        country?: components["schemas"]["CountryParam"];
        postcode_type?: components["schemas"]["PostcodeTypeParam"];
        su_organisation_indicator?: components["schemas"]["SmallUserParam"];
        box?: components["schemas"]["BoxParam"];
        bias_postcode_outward?: components["schemas"]["BiasPostcodeOutwardParam"];
        bias_postcode?: components["schemas"]["BiasPostcodeParam"];
        bias_postcode_area?: components["schemas"]["BiasPostcodeAreaParam"];
        bias_postcode_sector?: components["schemas"]["BiasPostcodeSectorParam"];
        bias_post_town?: components["schemas"]["BiasPosttownParam"];
        bias_thoroughfare?: components["schemas"]["BiasThoroughfareParam"];
        bias_country?: components["schemas"]["BiasCountryParam"];
        bias_lonlat?: components["schemas"]["BiasLonLatParam"];
        bias_ip?: components["schemas"]["BiasIpParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        headers: {
          /** The maximum number of requests that can be made in 5 minutes */
          "X-RateLimit-Limit"?: number;
          /** The remaining requests within the current rate limit window */
          "X-RateLimit-Remaining"?: number;
          /** The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds. */
          "X-RateLimit-Reset"?: number;
        };
        content: {
          "application/json": components["schemas"]["AutocompleteResponse"];
        };
      };
    };
  };
  /**
   * Resolves an address autocompletion by its address ID.
   *
   * Resolved addresses (including global addresses) are returned in a UK format (up to 3 address lines) using UK nomenclature (like postcode and county).
   */
  Resolve: {
    parameters: {
      path: {
        /** ID of address suggestion */
        address: string;
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GbrResolveAddressResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
   *
   * If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
   *
   * This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
   *
   * For address finder, see our address finder API - which is designed for speed and ergonomics.
   *
   * ### JavaScript Example
   *
   * ```javascript
   * const { Client, lookupAddress } = require("@ideal-postcodes/core-node");
   *
   * const client = new Client({ api_key: "iddqd" });
   *
   * await lookupAddress({ client, query: "10 Brompton Rd" });
   * ```
   *
   * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#search-for-an-address)
   *
   * ## Filters
   *
   * You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
   *
   * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
   *
   * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
   *
   * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
   *
   * All filters can accept multiple terms unless stated otherwise below.
   *
   * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
   *
   * A combined maximum of 5 terms are allowed across all filters.
   *
   * ## Biases
   *
   * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
   *
   * Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
   *
   * For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
   *
   * If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
   *
   * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
   *
   * All biases can accept multiple terms unless stated otherwise below.
   *
   * A combined maximum of 5 terms are allowed across all biases.
   *
   * ## Search by Postcode and Building Name or Number
   *
   * Search by postcode and building attribute with the postcode filter and query argument. E.g. For "SW1A 2AA Prime Minister" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
   *
   * The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
   *
   * #### Search By UPRN
   *
   * Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
   *
   * ## Testing
   *
   * - **ID1 1QD** Returns a successful query response `2000`
   * - **ID1 KFA** Returns an empty query response `2000`
   * - **ID1 CLIP** Returns "no lookups remaining" error `4020`
   * - **ID1 CHOP** Returns "daily (or individual) lookup limit breached" error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  Addresses: {
    parameters: {
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        /** Specifies the address you wish to query. Query can be shortened to `q=` */
        query?: string;
        limit?: components["schemas"]["LimitParam"];
        page?: components["schemas"]["PageParam"];
        filter?: components["schemas"]["FilterParam"];
        postcode_outward?: components["schemas"]["PostcodeOutwardParam"];
        postcode?: components["schemas"]["PostcodeParam"];
        postcode_area?: components["schemas"]["PostcodeAreaParam"];
        postcode_sector?: components["schemas"]["PostcodeSectorParam"];
        post_town?: components["schemas"]["PostTownParam"];
        uprn?: components["schemas"]["UPRNParam"];
        country?: components["schemas"]["CountryParam"];
        postcode_type?: components["schemas"]["PostcodeTypeParam"];
        su_organisation_indicator?: components["schemas"]["SmallUserParam"];
        box?: components["schemas"]["BoxParam"];
        bias_postcode_outward?: components["schemas"]["BiasPostcodeOutwardParam"];
        bias_postcode?: components["schemas"]["BiasPostcodeParam"];
        bias_postcode_area?: components["schemas"]["BiasPostcodeAreaParam"];
        bias_postcode_sector?: components["schemas"]["BiasPostcodeSectorParam"];
        bias_post_town?: components["schemas"]["BiasPosttownParam"];
        bias_thoroughfare?: components["schemas"]["BiasThoroughfareParam"];
        bias_country?: components["schemas"]["BiasCountryParam"];
        bias_lonlat?: components["schemas"]["BiasLonLatParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["AddressResponse"];
        };
      };
    };
  };
  /** Returns a list of licensees for a key. */
  ListLicensees: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** Specify ID of the licensee after which you would like to list results */
        starting_after?: number;
        user_token: components["schemas"]["UserTokenParam"];
        /** Specify the maximum number of results to return per page. Default and maximum is `100`. */
        limit?: components["schemas"]["LimitParam"];
        /** Filter result by licensee name. Query can be shortened to `q=` */
        query?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseesResponse"];
        };
      };
    };
  };
  /** Create a licensee for the specified API Key. */
  CreateLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LicenseeEditable"];
      };
    };
  };
  /** Returns licensee information as identified by the licensee key. */
  RetrieveLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
    };
  };
  /** Update Licensee */
  UpdateLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LicenseeEditable"];
      };
    };
  };
  /** Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us. */
  DeleteLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: int32
               * @example 1
               */
              deleted: number;
            };
            /**
             * Format: int32
             * @enum {integer}
             */
            code: 2000;
            /** @enum {string} */
            message: "Success";
          };
        };
      };
    };
  };
  /** Lists configurations associated with a key */
  ListConfigs: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigsResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
    };
  };
  /** Create a config */
  CreateConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfigNewParam"];
      };
    };
  };
  /** Retrieve config object by name */
  RetrieveConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
  };
  /** Updates configuration object */
  UpdateConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfigUpdateParam"];
      };
    };
  };
  /** Permanently deletes a configuration object. */
  DeleteConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: int32
               * @example 1
               */
              deleted: number;
            };
            /**
             * Format: int32
             * @enum {integer}
             */
            code: 2000;
            /** @enum {string} */
            message: "Success";
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
  };
}

export interface external {}

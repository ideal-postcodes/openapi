/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/postcodes/{postcode}": {
    /**
     * Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
     *
     * The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
     *
     * ## JavaScript Example
     *
     * ```javascript
     * const { Client, postcodes } = require("@ideal-postcodes/core-node");
     *
     * const api_key = "iddqd";
     *
     * const client = new Client({ api_key: "iddqd" });
     *
     * await postcodes.retrieve(client, "ID1 1QD", { query: { api_key } });
     * ```
     *
     * This API models postcodes as a HTTP resource. The above example provides a thin JavaScript abstraction and more control over the HTTP request and response. The JavaScript client also provides a number of terser helper methods like [`client.lookupPostcode`](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
     *
     * If you wish to quickly add Postcode Lookup driven address finder on your page, see our [Postcode Lookup plugin](/postcode-lookup) and [associated demos](/postcode-lookup-demo).
     *
     * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
     *
     * ## Postcode Not Found
     *
     * Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
     *
     * ```json
     * {
     *   "code": 4040,
     *   "message": "Postcode not found",
     *   "suggestions": ["SW1A 0AA"]
     * }
     * ```
     *
     * ### Suggestions
     *
     * If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
     *
     * If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
     *
     * The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
     *
     * ## Multiple Residence
     *
     * A small number of  postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
     *
     * ```javascript
     * const { lookupPostcode, Client } = require("@ideal-postcodes/core-node");
     *
     * const client = new Client({ api_key: "iddqdmr" });
     *
     * await lookupPostcode({ client, postcode: "CV4 7AL", page: 1 });
     * ```
     *
     * ## Testing
     *
     * We have a range of test postcodes that yield both successful and unsuccessful responses to your request. They are the following
     *
     * - `ID1 1QD` Returns a successful Postcode Lookup response `2000`
     * - `ID1 KFA` Returns "postcode not found", error `4040`
     * - `ID1 CLIP` Returns "no lookups remaining", error `4020`
     * - `ID1 CHOP` Returns "daily (or individual) lookup limit breached", error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["Postcodes"];
  };
  "/udprn/{udprn}": {
    /**
     * Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
     *
     * You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
     *
     * UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
     *
     * ## Testing
     *
     * To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
     *
     * They are the following:
     *
     * - `0` Returns a successful UDPRN lookup response
     *   `2000`
     * - `-1` Returns "UDPRN not found", error `4044`
     * - `-2` Returns "no lookups remaining", error `4020`
     * - `-3` Returns "daily (or individual) lookup limit breached",
     *   error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["UDPRN"];
  };
  "/umprn/{umprn}": {
    /**
     * Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
     *
     * UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
     *
     * ## Testing
     *
     * To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
     *
     * - `0` Returns a successful UMPRN lookup response `2000`
     * - `-1` Returns "UMPRN not found", error `4044`
     * - `-2` Returns "no lookups remaining", error `4020`
     * - `-3` Returns "daily (or individual) lookup limit breached", error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     *
     * ### Pricing
     *
     * Per lookup charges apply. Empty responses are not charged.
     */
    get: operations["UMPRN"];
  };
  "/keys/{key}": {
    /**
     * Returns public information on key. Currently only returns whether the key is currently useable via the `available` property. Use this to discover if the key is useable before making further requests.
     *
     * You may pass both API Keys (beginning `ak_`) and Sub-licensed Keys (beginning `sl_`).
     * ## Testing
     *
     * To test your implementation of our API, you may use the following test keys.
     *
     * - **iddqd** Availability will return as `true`
     * - **idkfa** Availability will return as `false`
     */
    get: operations["KeyAvailability"];
  };
  "/keys/{key}/details": {
    /** Returns private data on the key including remaining lookups, available datasets and usage limits. */
    get: operations["KeyDetails"];
  };
  "/keys/{key}/usage": {
    /**
     * Reports the number of lookups consumed on a key for a range of days.
     *
     * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
     */
    get: operations["KeyUsage"];
  };
  "/keys/{key}/lookups": {
    /**
     * Reports lookup information on a key for paid lookups.
     *
     * This method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).
     *
     * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
     *
     * ## Download Usage History (CSV)
     *
     * `GET /keys/:key/lookups`
     *
     * Returns a CSV download of lookups performed and associated information.
     *
     * Note that the Content-Type returned will be CSV (text/csv). For a non 200 response, the `Content-Type` will revert to JSON with the error code and message embedded.
     *
     * ## Data Redaction
     *
     * Personally Identifiable Data (PII) caught in this your usage log (including IP, search term and URL data) will be redacted on a weekly basis.
     *
     * By default, PII will be redacted if it is older than 21 days. This timeframe can be configured from your dashboard.
     *
     * You may prevent PII collection altogether by setting the interval to `0` days.
     */
    get: operations["KeyLogs"];
  };
  "/autocomplete/addresses": {
    /**
     * The address autocomplete API returns a list of address suggestions that match the query ordered by relevance score.
     *
     * This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
     *
     * If you wish to quickly add address autocompletion to your address forms, see [Address Finder](/address-finder) and [associated demos](/address-finder-demo).
     *
     * ## Implementing Address Autocomplete
     *
     * Retrieving addresses using Address Autocomplete is a 2 step process.
     *
     * 1. Retrieve partial address suggestions via `/autocomplete/addresses`
     * 2. Retrieve the entire address by following the URL provided by the suggestion
     *
     * Step 2 will decrement your lookup balance.
     *
     * Please note, this API is not intended to be a free standalone resource.
     *
     * ### JavaScript Example
     *
     * #### Step 1. Retrieve a list of suggestions
     *
     * ```javascript
     * const { Client, autocomplete } = require("@ideal-postcodes/core-node");
     *
     * const response = await autocomplete.list(client, {
     *   query: {
     *     query: "221b bake",
     *     api_key: "iddqd",
     *   },
     * });
     * ```
     *
     * #### Step 2. Resolve a suggestion retrieved above for a full address
     *
     * ```javascript
     * const { lookupUdprn } = require("@ideal-postcodes/core-node");
     *
     * const udprn = 17646242;
     *
     * await lookupUdprn({ client, udprn });
     * ```
     *
     * ## Filters
     *
     * You can strictly narrow your result by adding filters to your querystring which correspond with an address attribute.
     *
     * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
     *
     * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
     *
     * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are <code>OR</code>'ed, i.e. the matching result sets are combined.
     *
     * All filters can accept multiple terms unless stated otherwise below.
     *
     * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are <code>AND</code>'ed, i.e. each additional filter narrows the result set.
     *
     * A maximum of **10** terms are allowed across all filters.
     *
     * ## Biases
     *
     * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
     *
     * Biased searches, unlike filtered searches, also allow unmatched addresses to appear. These will rank lower.
     *
     * For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
     *
     * No bias effect applies to bias terms that are invalid.
     * e.g. `bias_postcode=SW1A2AAA`
     *
     * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
     *
     * All biases can accept multiple terms unless stated otherwise below.
     *
     * A combined maximum of **5** terms are allowed across all biases.
     *
     * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
     *
     * ## Suggestion Format
     *
     * The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
     *
     * ## Querying with a Postcode
     *
     * - If a postcode is passed as a query, all addresses for that postcode will be listed as the result if the limit parameter is not supplied
     * - If a postcode forms only part of the query, your autocomplete results will be filtered by that postcode
     *
     * ## Querying Multiple Residence
     *
     * For Multiple Residence enabled keys, any Multiple Residence households will also return a UMPRN id. This can be retrieved with the `/umprn/:id` endpoint.
     * Note that Multiple Residence households will always have:
     * - A parent premise with a UDPRN
     * - A single UDPRN premise may have many Multiple Residence households with different UMPRNs.
     *
     * ## Rate Limiting
     *
     * You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
     *
     * | Header                  | Description                                                                            |
     * | ----------------------- | -------------------------------------------------------------------------------------- |
     * | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
     * | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
     * | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
     *
     * ## Pricing
     *
     * This API currently does not affect your balance. However, subsequent searches require a paid request (e.g. a UDPRN search). This paid request, will yield the complete address.
     *
     * Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
     *
     * ## Testing
     *
     * `ID1 1QD` will return address suggestions, that when retrieved via `/udprn/:id` will not affect your balance.
     */
    get: operations["AddressAutocomplete"];
  };
  "/addresses": {
    /**
     * Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
     *
     * If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
     *
     * This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
     *
     * For address finder, see our address finder API - which is designed for speed and ergonomics.
     *
     * ### JavaScript Example
     *
     * ```javascript
     * const { Client, lookupAddress } = require("@ideal-postcodes/core-node");
     *
     * const client = new Client({ api_key: "iddqd" });
     *
     * await lookupAddress({ client, query: "10 Brompton Rd" });
     * ```
     *
     * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#search-for-an-address)
     *
     * ## Filters
     *
     * You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
     *
     * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
     *
     * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
     *
     * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
     *
     * All filters can accept multiple terms unless stated otherwise below.
     *
     * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
     *
     * A combined maximum of 5 terms are allowed across all filters.
     *
     * ## Biases
     *
     * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
     *
     * Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
     *
     * For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
     *
     * If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
     *
     * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
     *
     * All biases can accept multiple terms unless stated otherwise below.
     *
     * A combined maximum of 5 terms are allowed across all biases.
     *
     * ## Search by Postcode and Building Name or Number
     *
     * Search by postcode and building attribute with the postcode filter and query argument. E.g. For "SW1A 2AA Prime Minister" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
     *
     * The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
     *
     * #### Search By UPRN
     *
     * Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
     *
     * ## Testing
     *
     * - **ID1 1QD** Returns a successful query response `2000`
     * - **ID1 KFA** Returns an empty query response `2000`
     * - **ID1 CLIP** Returns "no lookups remaining" error `4020`
     * - **ID1 CHOP** Returns "daily (or individual) lookup limit breached" error `4021`
     *
     * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
     */
    get: operations["Addresses"];
  };
  "/keys/{key}/licensees": {
    /** Returns a list of licensees for a key. */
    get: operations["ListLicensees"];
    /** Create a licensee for the specified API Key. */
    post: operations["CreateLicensee"];
  };
  "/keys/{key}/licensees/{licensee}": {
    /** Returns licensee information as identified by the licensee key. */
    get: operations["RetrieveLicensee"];
    /** Update Licensee */
    put: operations["UpdateLicensee"];
    /** Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us. */
    delete: operations["DeleteLicensee"];
  };
  "/keys/{key}/configs": {
    /** Lists configurations associated with a key */
    get: operations["ListConfigs"];
    /** Create a config */
    post: operations["CreateConfig"];
  };
  "/keys/{key}/configs/{config}": {
    /** Retrieve config object by name */
    get: operations["RetrieveConfig"];
    /** Updates configuration object */
    post: operations["UpdateConfig"];
    /** Permanently deletes a configuration object. */
    delete: operations["DeleteConfig"];
  };
}

export interface components {
  schemas: {
    /** Correctly formatted postcode. Capitalised and spaced. */
    Postcode: string;
    /**
     * Your Ideal Postcodes API Key. Typically beings `ak_`.
     *
     * Available from your dashboard
     */
    ApiKeyParam: string;
    /**
     * Comma separated whitelist of address elements to return.
     *
     * E.g. `filter=line_1,line_2,line_3` returns only `line_1`, `line_2` and `line_3` address elements in your response
     */
    FilterParam: string;
    /**
     * 0 indexed indicator of the page of results to receive. Virtually all postcode results are returned on page 0.
     *
     * A small number of Multiple Residence postcodes may need pagination (i.e. have more than 100 premises).
     */
    PageParam: number;
    /** The first part of a postcode is known as the outward code. e.g. The outward code of ID1 1QD is ID1. Enables mail to be sorted to the correct local area for delivery. This part of the code contains the area and the district to which the mail is to be delivered, e.g. ‘PO1’, ‘SW1A’ or ‘B23’. */
    PostcodeOutward: string;
    /** The second part of a postcode is known as the inward Code. e.g.  The inward code of ID1 1QD is 1QD. This part is one number followed by two letters.  The number identifies the sector in the postal district.  The letters then define one or more properties in that sector. */
    PostcodeInward: string;
    /** A Post Town is mandatory for delivery of mail to a Delivery Point. This is not necessarily the nearest town geographically, but a routing instruction to the Royal Mail delivery office sorting mail for that Delivery Point. A Post Town will always be present in every address, and for some Localities the Post Town will be the only locality element present. */
    PostTown: string;
    /** When the same thoroughfare name reoccurs in a Post town, it may not be possible to make it dependant on a dependant thoroughfare. In this case the thoroughfare is dependant on a locality. For example if we want to find 1 Back Lane in Huddersfield we see that there are three. */
    DependantLocality: string;
    /** Used to supplement Dependant Locality. A Double Dependant Locality supplied along with a Dependant Locality if the Dependant Locality exists twice in the same locality. */
    DoubleDependantLocality: string;
    /** Also known as the street or road name. In general each Thoroughfare Name will have a separate Postcode. Longer Thoroughfares with high number ranges often have multiple Postcodes covering the entire length of the road, with breaks at suitable points e.g. junctions or natural breaks in the road. */
    Thoroughfare: string;
    /** Used to supplement thoroughfare. When a thoroughfare name is used twice in the same Post Town, the dependant thoroughfare is added to uniquely indentify a delivery point. */
    DependantThoroughfare: string;
    /** Number to identify premise on a thoroughfare or dependant thoroughfare. */
    BuildingNumber: string;
    /** Name of residential or commercial premise. E.g. The Manor, 1-2, A, 12A, K, Victoria House */
    BuildingName: string;
    /** When a premise is split into individual units such as flats, apartments or business units. Cannot be present without either building_name or building_number. E.g. Flat 1, A, 10B */
    SubBuildingName: string;
    /** When the PO Box Number field is populated it will contain PO BOX nnnnnn where n represents the PO Box number. Note that the PO Box details can occasionally consist of a combination of numbers and letters. PO Box Numbers are only allocated to Large Users. */
    POBox: string;
    /** Used to supplment Organisation Name to identify a deparment within the organisation. */
    DepartmentName: string;
    /** Used to supplment Organisation Name to identify a deparment within the organisation. */
    OrganisationName: string;
    /** A small minority of individual premises (as identified by a UDPRN) may have multiple occupants behind the same letterbox. These are known as Multiple Residence occupants and can be queried via the Multiple Residence dataset. Simple, unique reference number for each Multiple Residence occupant. 8-character numeric code. Note: this will be an empty string `""` when not used for legacy reasons */
    UMPRN: "" | number;
    /** This indicates the type of user. It can only take the values 'S' or 'L' indicating small or large respectively. Large User Postcodes. These are assigned to one single address either due to the large volume of mail received at that address, or because a PO Box or Selectapost service has been set up. Small User Postcodes. These identify a group of Delivery Points. On average there are 15 Delivery Points per Postcode. However this can vary between 1 and, in some cases, 100. There will never be more than 100 Delivery Points on a Postcode. */
    PostcodeType: "S" | "L";
    /** Small User Organisation Indicator can have the values 'Y' or space. A value of 'Y' indicates that a Small User Organisation is present at this address. */
    SuOrganisationIndicator: string;
    /** A unique Royal Mail 2-character code (the first numeric & the second alphabetical), which, when added to the Postcode, enables each live Delivery Point to be uniquely identified. Once the Delivery Point is deleted from PAF the DPS may be reused (although they aren’t reused until all remaining Delivery Points in the range have been allocated). The DPS for a Large User is always '1A' as each Large User has its own Postcode. E.g. 2B */
    DeliveryPointSuffix: string;
    /** First Address Line. Often contains premise and thoroughfare information. In the case of a commercial premise, the first line is always the full name of the registered organisation. Never empty. */
    Line1: string;
    /** Second Address Line. Often contains thoroughfare and locality information. May be empty. */
    Line2: string;
    /** Third address line. May be empty. */
    Line3: string;
    /** A pre-computed string which sensibly combines building_number, building_name and sub_building_name. building_number, building_name and sub_building_name represent raw data from Royal Mail's and can be difficult to parse if you are unaware of how the Postcode Address File premise fields work together. For this reason, we also provide a pre-computed premise field which intelligently gathers these points into a single, simple premise string. This field is ideal if you want to pull premise information and thoroughfare information separately instead of using our address lines data. */
    Premise: string;
    /** The country for which the postcode belongs to. May be empty for a small number of addresses. Data source: ONS */
    Country: string;
    /** Since postal, administrative or traditional counties may not apply to some addresses, the county field is designed to return whatever county data is available. Normally, the postal county is returned. If this is not present, the county field will fall back to the administrative county. If the administrative county is also not present, the county field will fall back to the traditional county. May be empty in cases where no administrative, postal or traditional county present. */
    County: string;
    /** The current administrative county to which the postcode has been assigned. A Unitary Authority name, where one is present. If there is no Unitary Authority, the County name is used. This information is not static, because County boundaries may change due to administrative changes. Data source: ONS. May be empty. */
    AdministrativeCounty: string;
    /** Postal counties were used for the distribution of mail before the Postcode system was introduced in the 1970s. The Former Postal County was the Administrative County at the time. This data rarely changes. Data source: Royal Mail. May be empty. */
    PostalCounty: string;
    /** The current district/unitary authority to which the postcode has been assigned. Data source: ONS */
    District: string;
    /** The current administrative/electoral area to which the postcode has been assigned. May be empty for a small number of addresses. Data source: ONS */
    Ward: string;
    /** The longitude of the postcode (WGS84/ETRS89). Accurate at the postcode level Can be a positive or negative decimal. E.g. -0.1283983 Returns an empty string if no location data is available.  Otherwise, a number is returned */
    Longitude: "" | number;
    /** The latitude of the postcode (WGS84/ETRS89). Accurate at the postcode level Can be a positive or negative decimal. E.g. 51.5083983 Returns an empty string if no location data is available.  Otherwise a number is returned. */
    Latitude: "" | number;
    /** Eastings reference using the [Ordnance Survey National Grid reference system](https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid) Northern Ireland Eastings uses the [Irish Grid Reference System](https://en.wikipedia.org/wiki/Irish_grid_reference_system) Metres from origin. E.g. 550458 Returns an empty string if no location data is available. Otherwise a number is returned */
    Eastings: "" | number;
    /** Northings reference using the [Ordnance Survey National Grid reference system](https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid) Northern Ireland Northings uses the [Irish Grid Reference System](https://en.wikipedia.org/wiki/Irish_grid_reference_system) Metres from origin. E.g. 180458 Returns an empty string if no location data is available. Otherwise a number is returned */
    Northings: "" | number;
    /** UPRN stands for Unique Property Reference Number and is maintained by the Ordnance Survey (OS). Local governments in the UK have allocated a unique number for each land or property. See our UPRN guide for more information. Up to 12 digits in length. Multiple Residence premises currently share the same UPRN as the parent premise. May not be available for a small number of Great Britain addresses due to longer update cycles for Ordnance Survey's AddressBase datasets. Returns empty string "" in these instances. Although UPRN takes an integer format, we encode and transmit this data as strings. As a 12 digit number, the UPRN can exceed the maximum safe integer (Number.MAX_SAFE_INTEGER) in most browsers causing this datapoint to be corrupted. Take special care when storing UPRN. As a 12 digit identifier, you will need 64 bits to encode every possible UPRN value. */
    UPRN: string;
    PafAddress: {
      postcode: components["schemas"]["Postcode"];
      postcode_outward: components["schemas"]["PostcodeOutward"];
      postcode_inward: components["schemas"]["PostcodeInward"];
      post_town: components["schemas"]["PostTown"];
      dependant_locality: components["schemas"]["DependantLocality"];
      double_dependant_locality: components["schemas"]["DoubleDependantLocality"];
      thoroughfare: components["schemas"]["Thoroughfare"];
      dependant_thoroughfare: components["schemas"]["DependantThoroughfare"];
      building_number: components["schemas"]["BuildingNumber"];
      building_name: components["schemas"]["BuildingName"];
      sub_building_name: components["schemas"]["SubBuildingName"];
      po_box: components["schemas"]["POBox"];
      department_name: components["schemas"]["DepartmentName"];
      organisation_name: components["schemas"]["OrganisationName"];
      udprn: components["schemas"]["UMPRN"];
      umprn: components["schemas"]["UMPRN"];
      postcode_type: components["schemas"]["PostcodeType"];
      su_organisation_indicator: components["schemas"]["SuOrganisationIndicator"];
      delivery_point_suffix: components["schemas"]["DeliveryPointSuffix"];
      line_1: components["schemas"]["Line1"];
      line_2: components["schemas"]["Line2"];
      line_3: components["schemas"]["Line3"];
      premise: components["schemas"]["Premise"];
      country: components["schemas"]["Country"];
      county: components["schemas"]["County"];
      administrative_county: components["schemas"]["AdministrativeCounty"];
      postal_county: components["schemas"]["PostalCounty"];
      traditional_county: components["schemas"]["PostalCounty"];
      district: components["schemas"]["District"];
      ward: components["schemas"]["Ward"];
      longitude: components["schemas"]["Longitude"];
      latitude: components["schemas"]["Latitude"];
      eastings: components["schemas"]["Eastings"];
      northings: components["schemas"]["Northings"];
      uprn?: components["schemas"]["UPRN"];
    };
    MrAddress: components["schemas"]["PafAddress"] & {
      umprn: number;
    };
    NybAddress: components["schemas"]["PafAddress"];
    PostcodeResponse: {
      /** All addresses listed at the postcode */
      result: (Partial<components["schemas"]["PafAddress"]> &
        Partial<components["schemas"]["MrAddress"]> &
        Partial<components["schemas"]["NybAddress"]>)[];
      code: 2000;
      message: "Success";
    };
    PostcodeNotFoundResponse: {
      code: 4040;
      message: "Postcode not found";
      /** A list of alternate nearest matching postcodes you can try */
      suggestions: string[];
    };
    UDPRNResponse: {
      result:
        | components["schemas"]["PafAddress"]
        | components["schemas"]["NybAddress"];
      code: 2000;
      message: "Success";
    };
    ErrorResponse: {
      /** API Response Code. Non `2xxx` code indicates a failure. This code will provide a more specific reason when a failure occurs and facilitates debugging. */
      code: number;
      /** Human readable error message supplied with every error response. */
      message: string;
    };
    UMPRNResponse: {
      result: components["schemas"]["MrAddress"];
      code: 2000;
      message: "Success";
    };
    ApiKey: {
      /**
       * Determines whether the key can be used by the requesting agent.
       *
       * Returns false if one of the following conditions are met:
       *   - Key has no lookups remaining
       *   - Daily limit has been reached on the key
       *   - Daily individual limit has been reached
       *   - Key is not being used via an authorised URL
       *   - (Sublicensed key only) Key has a valid licensee attached
       *   - (Sublicensed key only) Key is not being used via an authorised URL specified by licensee
       */
      available?: boolean;
    } & {
      availabie: unknown;
    };
    ApiKeyResponse: {
      result: components["schemas"]["ApiKey"];
      message: "Success";
      code: 2000;
    };
    /**
     * A secret key used for sensitive operations on your account and API Keys.
     *
     * Your user token can be retrieved and managed from your [accounts page](https://ideal-postcodes.co.uk/account).
     *
     * Typically beings `uk_...`
     */
    UserTokenParam: string;
    ApiKeyDailyLimit: {
      /**
       * `number` or `null`. The daily lookup limit currently set on your key.
       * `null` means the limit is currently disabled.
       */
      limit: number;
      /** Number of lookups performed today which count towards your daily limit. */
      consumed: number;
    };
    ApiKeyIndividualLimit: {
      /**
       * `number` or `null` Limit set on the number of lookups that can be
       * performed from a single IP address. `null` means the limit is currently
       * disabled.
       */
      limit: number;
    };
    ApiKeyNotifications: {
      /** A list of email addresses designated by you to receive notifications about this key. */
      emails: string[];
      /** Indicates whether email notifications are enabled. */
      enabled: boolean;
    };
    /** Automated topup status */
    ApiKeyAutomatedTopup: {
      /** Indicates whether automated top-ups are enabled */
      enabled: boolean;
    };
    ApiKeyCurrentPurchase: {
      /**
       * `string` or `null` The date when this purchase will expire in simplified
       * extended ISO format (ISO 8601). This is typically 365 days from the time
       * of first use. This field will be `null` if the purchase has not yet been
       * used.
       */
      expires: string;
      /** Number of procured lookups from this purchase. */
      purchased: number;
      /** Number of consumed lookups off this purchase. */
      consumed: number;
    };
    ApiKeyDetails: {
      lookups_remaining: number;
      daily_limit: components["schemas"]["ApiKeyDailyLimit"];
      individual_limit: components["schemas"]["ApiKeyIndividualLimit"];
      /** A list of allowed URLs. An empty list means that allowed URLs are disabled. */
      allowed_urls: string[];
      notifications?: components["schemas"]["ApiKeyNotifications"];
      automated_topups: components["schemas"]["ApiKeyAutomatedTopup"];
      /** Current balance purchases attached to key. */
      current_purchases: components["schemas"]["ApiKeyCurrentPurchase"][];
    } & {
      notificatinos: unknown;
    };
    ApiKeyDetailsResponse: {
      result: components["schemas"]["ApiKeyDetails"];
      code: 2000;
      message: "Success";
    };
    /** A start date/time in the form of a UNIX Timestamp in milliseconds, e.g.  `1418556452651`. */
    StartParam: number;
    /** An start date/time in the form of a UNIX Timestamp in milliseconds, e.g.  `1418556477882`. */
    EndParam: number;
    /**
     * A comma separated list of tags to query over.
     *
     * Useful if you want to specify the circumstances in which the request was made.
     *
     * If multiple tags are specified, the response will only comprise of requests for which all the tags are satisfied - i.e. searching `"foo,bar"` will only query requests which tagged both `"foo"` and `"bar"`.
     */
    TagsParam: string;
    /** Uniquely identifies a licensee */
    LicenseeParam: string;
    KeyUsageResult: {
      /** Start date in ISO 8601 format. */
      start: string;
      /** End date in ISO 8601 format. */
      end: string;
      /** Total of paid lookups performed in specified period. */
      total: number;
      /** An array of objects representing number of paid lookups made on specific days, ordered by date. Each object contains a `date` attribute, which represents the day and a `count` attribute, which represents the number of paid lookups made on that day. */
      dailyCount: {
        date: string;
        count: number;
      }[];
    };
    ApiKeyUsageResponse: {
      result: components["schemas"]["KeyUsageResult"];
      code: 2000;
      message: "Success";
    };
    /**
     * Specifies the maximum number of suggestions to retrieve.
     *
     * By default the limit is 10, unless a postcode is queried (then all addresses at that postcode will be returned). Limit can be shortened to `l=`
     */
    LimitParam: number;
    /** Filter by outward code. */
    PostcodeOutwardParam: string;
    /** Filter by postcode. Can be combined with query to perform a postcode + building number/name search. */
    PostcodeParam: string;
    /** Filter by postcode. Can be combined with query to perform a postcode + building number/name search. */
    PostcodeAreaParam: string;
    /** Filter by postcode sector, the outward code plus first numeric of the inward code. */
    PostcodeSectorParam: string;
    /** Filter by town. */
    PostTownParam: string;
    /** Filters by UPRN. Does not accept comma separated terms. Only a single term is permitted */
    UPRNParam: number;
    /** Filter by country. Possible values are England, Scotland, Wales, Northern Ireland, Jersey, Guernsey and Isle of Man. */
    CountryParam: string;
    /** Filter by Postcode Type. Useful for separating organisational and residential addresses */
    PostcodeTypeParam: string;
    /** Filter by Organisation Indicator. Useful for separating organisational and residential addresses */
    SmallUserParam: string;
    /** Restrict search to a geospatial box determined by the "top-left" and "bottom-right" gelocations.   Only one geospatial box can be provided. */
    BoxParam: string;
    /** Bias by outward code */
    BiasPostcodeOutwardParam: string;
    /** Bias by postcode. Can be combined with query to perform a postcode + building number/name search. */
    BiasPostcodeParam: string;
    /** Bias by postcode area, the first one or two non-numeric characters of a postcode. */
    BiasPostcodeAreaParam: string;
    /** Bias by postcode sector, the outward code plus first numeric of the inward code. */
    BiasPostcodeSectorParam: string;
    /** Bias by town. */
    BiasPosttownParam: string;
    /** Bias by street name. */
    BiasThoroughfareParam: string;
    /** Bias by country. Possible values are England, Scotland, Wales, Northern Ireland, Jersey, Guernsey and Isle of Man. */
    BiasCountryParam: string;
    /** Bias search to a geospatial circle determined by an origin and radius in meters. Max radius is `50000`.  Uses the format bias_lonlat=[longitude],[latitude],[radius in metres] Only one geospatial bias may be provided */
    BiasLonLatParam: string;
    /** Can represent a PAF or Not Yet Built address */
    PafSuggestion: {
      /** Address suggestion for your given query. */
      suggestion: string;
      urls: {
        /** URL to retrieve the entire details for a given address suggestion */
        udprn: string;
      };
      /** Represents the UDPRN of a premise */
      udprn: number;
    };
    MrSuggestion: components["schemas"]["PafSuggestion"] & {
      urls: {
        /** Optionally returned field, to retrieve the entire details for a suggested Multiple Residence household */
        umprn: string;
      };
      /** Optionally returned field, representing the UMPRN of a Multiple Residence household */
      umprn: number;
    };
    NybSuggestion: components["schemas"]["PafSuggestion"];
    AutocompleteResponse: {
      result: (Partial<components["schemas"]["PafSuggestion"]> &
        Partial<components["schemas"]["MrSuggestion"]> &
        Partial<components["schemas"]["NybSuggestion"]>)[];
      code: 2000;
      message: "Success";
    };
    AddressResponse: {
      code: 2000;
      message: "Success";
      result: {
        /** List of matching addresses */
        hits: (Partial<components["schemas"]["PafAddress"]> &
          Partial<components["schemas"]["MrAddress"]> &
          Partial<components["schemas"]["NybAddress"]>)[];
        total: number;
        limit: number;
        page: number;
      };
    };
    /** Licensee object which can be defined by user */
    LicenseeEditable: {
      /** Licensee individual or organisation name */
      name?: string;
      /** Licensee's first, second and third line address as well as post town concatenated by commas */
      address?: string;
      /** Licensee's postcode */
      postcode?: string;
      /** A list of allowed URLs. An empty list means that whitelisting is disabled */
      whitelist?: string[];
      daily?: {
        /** The maximum number of lookups this licensee can perform in a day. `null` indicates the limit is not active */
        limit?: number;
      };
    };
    Licensee: components["schemas"]["LicenseeEditable"] &
      ({
        /** An immutable ID provided for every licensee. Primarily used for paginated list requests. */
        id: string;
        /**
         * Uniquely identifies a licensee for a key.
         *
         * Required to perform paid lookups for a specific licensee. Typically begins `sk_`.
         */
        key: string;
        /** Timestamp for when the licensee was created */
        createdAt: string;
        daily: {
          /** The number lookups performed by the licensee on the day represented b `licesees.daily.updatedAt` */
          count: number;
          /** The timestamp when the limit was last used. */
          updatedAt: string;
        };
      } & {
        name: unknown;
        address: unknown;
        postcode: unknown;
        whitelist: unknown;
      });
    LicenseesResponse: {
      /** List of licensees */
      result: {
        licensees?: components["schemas"]["Licensee"][];
        /** Returns true if there are more licensees listed after the maximum number of results as implied by `limit` */
        hasMore?: boolean;
      };
      message: "Success";
      code: 2000;
    };
    LicenseeResponse: {
      result: components["schemas"]["Licensee"];
      code: 2000;
      message: "Success";
    };
    Config: {
      /** Timestamp for when the config was created */
      updatedAt: string;
      /** Timestamp for when the config was updated */
      createdAt: string;
      /** A unique name to identify the configuration payload */
      name: string;
      /** A serialised payload of up to `4096` characters */
      payload: string;
    };
    ConfigsResponse: {
      /** List of configurations */
      result: {
        configs: components["schemas"]["Config"][];
      };
      message: "Success";
      code: 2000;
    };
    BadRequestResponse: components["schemas"]["ErrorResponse"] & {
      /** `400X` type error response code */
      code: number;
      /** Bad request error description */
      message: string;
      errors?: {
        /** Indicates location of error in request query or URL parameter */
        message: string;
        /** Indicates location of error in request query or URL parameter */
        path: string;
        errorCode?: string;
      }[];
    };
    UnauthorizedResponse: components["schemas"]["ErrorResponse"] & {
      /** `401X` type error response code */
      code: number;
      /** Unauthorized request error description */
      message: string;
    };
    /** Required configuration object parameters */
    ConfigNewParam: {
      /** A unique name to identify the configuration payload */
      name: string;
      /** A serialised payload of up to `4096` characters */
      payload: string;
    };
    ConfigResponse: {
      result: components["schemas"]["Config"];
      code: 2000;
      message: "Success";
    };
    /** User provided configuration object name */
    ConfigParam: string;
    NotFoundResponse: components["schemas"]["ErrorResponse"] & {
      /** `404X` type error response code */
      code: number;
      /** Resource not found error description */
      message: string;
    };
    /** Config object update parameters */
    ConfigUpdateParam: {
      /** A serialised payload of up to `4096` characters */
      payload?: string;
    };
  };
}

export interface operations {
  /**
   * Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
   *
   * The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
   *
   * ## JavaScript Example
   *
   * ```javascript
   * const { Client, postcodes } = require("@ideal-postcodes/core-node");
   *
   * const api_key = "iddqd";
   *
   * const client = new Client({ api_key: "iddqd" });
   *
   * await postcodes.retrieve(client, "ID1 1QD", { query: { api_key } });
   * ```
   *
   * This API models postcodes as a HTTP resource. The above example provides a thin JavaScript abstraction and more control over the HTTP request and response. The JavaScript client also provides a number of terser helper methods like [`client.lookupPostcode`](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
   *
   * If you wish to quickly add Postcode Lookup driven address finder on your page, see our [Postcode Lookup plugin](/postcode-lookup) and [associated demos](/postcode-lookup-demo).
   *
   * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
   *
   * ## Postcode Not Found
   *
   * Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
   *
   * ```json
   * {
   *   "code": 4040,
   *   "message": "Postcode not found",
   *   "suggestions": ["SW1A 0AA"]
   * }
   * ```
   *
   * ### Suggestions
   *
   * If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
   *
   * If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
   *
   * The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
   *
   * ## Multiple Residence
   *
   * A small number of  postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
   *
   * ```javascript
   * const { lookupPostcode, Client } = require("@ideal-postcodes/core-node");
   *
   * const client = new Client({ api_key: "iddqdmr" });
   *
   * await lookupPostcode({ client, postcode: "CV4 7AL", page: 1 });
   * ```
   *
   * ## Testing
   *
   * We have a range of test postcodes that yield both successful and unsuccessful responses to your request. They are the following
   *
   * - `ID1 1QD` Returns a successful Postcode Lookup response `2000`
   * - `ID1 KFA` Returns "postcode not found", error `4040`
   * - `ID1 CLIP` Returns "no lookups remaining", error `4020`
   * - `ID1 CHOP` Returns "daily (or individual) lookup limit breached", error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  Postcodes: {
    parameters: {
      path: {
        /** Postcode to retrieve */
        postcode: components["schemas"]["Postcode"];
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
        page?: components["schemas"]["PageParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["PostcodeResponse"];
        };
      };
      /** Postcode Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["PostcodeNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
   *
   * You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
   *
   * UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
   *
   * ## Testing
   *
   * To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
   *
   * They are the following:
   *
   * - `0` Returns a successful UDPRN lookup response
   *   `2000`
   * - `-1` Returns "UDPRN not found", error `4044`
   * - `-2` Returns "no lookups remaining", error `4020`
   * - `-3` Returns "daily (or individual) lookup limit breached",
   *   error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  UDPRN: {
    parameters: {
      path: {
        /** UDPRN to be retrieved */
        udprn: string;
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UDPRNResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
   *
   * UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
   *
   * ## Testing
   *
   * To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
   *
   * - `0` Returns a successful UMPRN lookup response `2000`
   * - `-1` Returns "UMPRN not found", error `4044`
   * - `-2` Returns "no lookups remaining", error `4020`
   * - `-3` Returns "daily (or individual) lookup limit breached", error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   *
   * ### Pricing
   *
   * Per lookup charges apply. Empty responses are not charged.
   */
  UMPRN: {
    parameters: {
      path: {
        /** UMPRN to be retrieved */
        umprn: string;
      };
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        filter?: components["schemas"]["FilterParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UMPRNResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns public information on key. Currently only returns whether the key is currently useable via the `available` property. Use this to discover if the key is useable before making further requests.
   *
   * You may pass both API Keys (beginning `ak_`) and Sub-licensed Keys (beginning `sl_`).
   * ## Testing
   *
   * To test your implementation of our API, you may use the following test keys.
   *
   * - **iddqd** Availability will return as `true`
   * - **idkfa** Availability will return as `false`
   */
  KeyAvailability: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyResponse"];
        };
      };
      /** Invalid Key */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Returns private data on the key including remaining lookups, available datasets and usage limits. */
  KeyDetails: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyDetailsResponse"];
        };
      };
      /** Resource not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Reports the number of lookups consumed on a key for a range of days.
   *
   * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
   */
  KeyUsage: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** A start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time. */
        start?: components["schemas"]["StartParam"];
        /** An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used. */
        end?: components["schemas"]["EndParam"];
        tags?: components["schemas"]["TagsParam"];
        /** Sublicensed keys only. This will restrict the analysed dataset to a specific licensee. */
        licensee?: components["schemas"]["LicenseeParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ApiKeyUsageResponse"];
        };
      };
    };
  };
  /**
   * Reports lookup information on a key for paid lookups.
   *
   * This method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).
   *
   * A maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.
   *
   * ## Download Usage History (CSV)
   *
   * `GET /keys/:key/lookups`
   *
   * Returns a CSV download of lookups performed and associated information.
   *
   * Note that the Content-Type returned will be CSV (text/csv). For a non 200 response, the `Content-Type` will revert to JSON with the error code and message embedded.
   *
   * ## Data Redaction
   *
   * Personally Identifiable Data (PII) caught in this your usage log (including IP, search term and URL data) will be redacted on a weekly basis.
   *
   * By default, PII will be redacted if it is older than 21 days. This timeframe can be configured from your dashboard.
   *
   * You may prevent PII collection altogether by setting the interval to `0` days.
   */
  KeyLogs: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** An start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time. */
        start?: components["schemas"]["StartParam"];
        /** An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used. */
        end?: components["schemas"]["EndParam"];
        /** Sublicensed keys only. This will restrict the analysed dataset to a specific licensee. */
        licensee?: components["schemas"]["LicenseeParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "text/csv": string;
        };
      };
    };
  };
  /**
   * The address autocomplete API returns a list of address suggestions that match the query ordered by relevance score.
   *
   * This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
   *
   * If you wish to quickly add address autocompletion to your address forms, see [Address Finder](/address-finder) and [associated demos](/address-finder-demo).
   *
   * ## Implementing Address Autocomplete
   *
   * Retrieving addresses using Address Autocomplete is a 2 step process.
   *
   * 1. Retrieve partial address suggestions via `/autocomplete/addresses`
   * 2. Retrieve the entire address by following the URL provided by the suggestion
   *
   * Step 2 will decrement your lookup balance.
   *
   * Please note, this API is not intended to be a free standalone resource.
   *
   * ### JavaScript Example
   *
   * #### Step 1. Retrieve a list of suggestions
   *
   * ```javascript
   * const { Client, autocomplete } = require("@ideal-postcodes/core-node");
   *
   * const response = await autocomplete.list(client, {
   *   query: {
   *     query: "221b bake",
   *     api_key: "iddqd",
   *   },
   * });
   * ```
   *
   * #### Step 2. Resolve a suggestion retrieved above for a full address
   *
   * ```javascript
   * const { lookupUdprn } = require("@ideal-postcodes/core-node");
   *
   * const udprn = 17646242;
   *
   * await lookupUdprn({ client, udprn });
   * ```
   *
   * ## Filters
   *
   * You can strictly narrow your result by adding filters to your querystring which correspond with an address attribute.
   *
   * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
   *
   * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
   *
   * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are <code>OR</code>'ed, i.e. the matching result sets are combined.
   *
   * All filters can accept multiple terms unless stated otherwise below.
   *
   * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are <code>AND</code>'ed, i.e. each additional filter narrows the result set.
   *
   * A maximum of **10** terms are allowed across all filters.
   *
   * ## Biases
   *
   * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
   *
   * Biased searches, unlike filtered searches, also allow unmatched addresses to appear. These will rank lower.
   *
   * For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
   *
   * No bias effect applies to bias terms that are invalid.
   * e.g. `bias_postcode=SW1A2AAA`
   *
   * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
   *
   * All biases can accept multiple terms unless stated otherwise below.
   *
   * A combined maximum of **5** terms are allowed across all biases.
   *
   * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#lookup-a-postcode)
   *
   * ## Suggestion Format
   *
   * The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
   *
   * ## Querying with a Postcode
   *
   * - If a postcode is passed as a query, all addresses for that postcode will be listed as the result if the limit parameter is not supplied
   * - If a postcode forms only part of the query, your autocomplete results will be filtered by that postcode
   *
   * ## Querying Multiple Residence
   *
   * For Multiple Residence enabled keys, any Multiple Residence households will also return a UMPRN id. This can be retrieved with the `/umprn/:id` endpoint.
   * Note that Multiple Residence households will always have:
   * - A parent premise with a UDPRN
   * - A single UDPRN premise may have many Multiple Residence households with different UMPRNs.
   *
   * ## Rate Limiting
   *
   * You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
   *
   * | Header                  | Description                                                                            |
   * | ----------------------- | -------------------------------------------------------------------------------------- |
   * | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
   * | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
   * | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
   *
   * ## Pricing
   *
   * This API currently does not affect your balance. However, subsequent searches require a paid request (e.g. a UDPRN search). This paid request, will yield the complete address.
   *
   * Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
   *
   * ## Testing
   *
   * `ID1 1QD` will return address suggestions, that when retrieved via `/udprn/:id` will not affect your balance.
   */
  AddressAutocomplete: {
    parameters: {
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        /** Specifies the address you wish to query. Query can be shortened to `q=` */
        query?: string;
        /** Limits number of address suggestions unless a postcode is detected. In this instance entire list of addreses for that postcode is returned. */
        limit?: components["schemas"]["LimitParam"];
        postcode_outward?: components["schemas"]["PostcodeOutwardParam"];
        postcode?: components["schemas"]["PostcodeParam"];
        postcode_area?: components["schemas"]["PostcodeAreaParam"];
        postcode_sector?: components["schemas"]["PostcodeSectorParam"];
        post_town?: components["schemas"]["PostTownParam"];
        uprn?: components["schemas"]["UPRNParam"];
        country?: components["schemas"]["CountryParam"];
        postcode_type?: components["schemas"]["PostcodeTypeParam"];
        su_organisation_indicator?: components["schemas"]["SmallUserParam"];
        box?: components["schemas"]["BoxParam"];
        bias_postcode_outward?: components["schemas"]["BiasPostcodeOutwardParam"];
        bias_postcode?: components["schemas"]["BiasPostcodeParam"];
        bias_postcode_area?: components["schemas"]["BiasPostcodeAreaParam"];
        bias_postcode_sector?: components["schemas"]["BiasPostcodeSectorParam"];
        bias_post_town?: components["schemas"]["BiasPosttownParam"];
        bias_thoroughfare?: components["schemas"]["BiasThoroughfareParam"];
        bias_country?: components["schemas"]["BiasCountryParam"];
        bias_lonlat?: components["schemas"]["BiasLonLatParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        headers: {
          /** The maximum number of requests that can be made in 5 minutes */
          "X-RateLimit-Limit"?: number;
          /** The remaining requests within the current rate limit window */
          "X-RateLimit-Remaining"?: number;
          /** The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds. */
          "X-RateLimit-Reset"?: number;
        };
        content: {
          "application/json": components["schemas"]["AutocompleteResponse"];
        };
      };
    };
  };
  /**
   * Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
   *
   * If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
   *
   * This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
   *
   * For address finder, see our address finder API - which is designed for speed and ergonomics.
   *
   * ### JavaScript Example
   *
   * ```javascript
   * const { Client, lookupAddress } = require("@ideal-postcodes/core-node");
   *
   * const client = new Client({ api_key: "iddqd" });
   *
   * await lookupAddress({ client, query: "10 Brompton Rd" });
   * ```
   *
   * [JavaScript client method documentation](https://github.com/ideal-postcodes/core-interface#search-for-an-address)
   *
   * ## Filters
   *
   * You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
   *
   * For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
   *
   * If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
   *
   * You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
   *
   * All filters can accept multiple terms unless stated otherwise below.
   *
   * Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
   *
   * A combined maximum of 5 terms are allowed across all filters.
   *
   * ## Biases
   *
   * You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
   *
   * Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
   *
   * For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
   *
   * If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
   *
   * You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
   *
   * All biases can accept multiple terms unless stated otherwise below.
   *
   * A combined maximum of 5 terms are allowed across all biases.
   *
   * ## Search by Postcode and Building Name or Number
   *
   * Search by postcode and building attribute with the postcode filter and query argument. E.g. For "SW1A 2AA Prime Minister" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
   *
   * The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
   *
   * #### Search By UPRN
   *
   * Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
   *
   * ## Testing
   *
   * - **ID1 1QD** Returns a successful query response `2000`
   * - **ID1 KFA** Returns an empty query response `2000`
   * - **ID1 CLIP** Returns "no lookups remaining" error `4020`
   * - **ID1 CHOP** Returns "daily (or individual) lookup limit breached" error `4021`
   *
   * Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
   */
  Addresses: {
    parameters: {
      query: {
        api_key: components["schemas"]["ApiKeyParam"];
        /** Specifies the address you wish to query. Query can be shortened to `q=` */
        query?: string;
        limit?: components["schemas"]["LimitParam"];
        page?: components["schemas"]["PageParam"];
        filter?: components["schemas"]["FilterParam"];
        postcode_outward?: components["schemas"]["PostcodeOutwardParam"];
        postcode?: components["schemas"]["PostcodeParam"];
        postcode_area?: components["schemas"]["PostcodeAreaParam"];
        postcode_sector?: components["schemas"]["PostcodeSectorParam"];
        post_town?: components["schemas"]["PostTownParam"];
        uprn?: components["schemas"]["UPRNParam"];
        country?: components["schemas"]["CountryParam"];
        postcode_type?: components["schemas"]["PostcodeTypeParam"];
        su_organisation_indicator?: components["schemas"]["SmallUserParam"];
        box?: components["schemas"]["BoxParam"];
        bias_postcode_outward?: components["schemas"]["BiasPostcodeOutwardParam"];
        bias_postcode?: components["schemas"]["BiasPostcodeParam"];
        bias_postcode_area?: components["schemas"]["BiasPostcodeAreaParam"];
        bias_postcode_sector?: components["schemas"]["BiasPostcodeSectorParam"];
        bias_post_town?: components["schemas"]["BiasPosttownParam"];
        bias_thoroughfare?: components["schemas"]["BiasThoroughfareParam"];
        bias_country?: components["schemas"]["BiasCountryParam"];
        bias_lonlat?: components["schemas"]["BiasLonLatParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["AddressResponse"];
        };
      };
    };
  };
  /** Returns a list of licensees for a key. */
  ListLicensees: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        /** Specify ID of the licensee after which you would like to list results */
        starting_after?: number;
        user_token: components["schemas"]["UserTokenParam"];
        /** Specify the maximum number of results to return per page. Default and maximum is `100`. */
        limit?: components["schemas"]["LimitParam"];
        /** Filter result by licensee name. Query can be shortened to `q=` */
        query?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseesResponse"];
        };
      };
    };
  };
  /** Create a licensee for the specified API Key. */
  CreateLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LicenseeEditable"];
      };
    };
  };
  /** Returns licensee information as identified by the licensee key. */
  RetrieveLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
    };
  };
  /** Update Licensee */
  UpdateLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseeResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LicenseeEditable"];
      };
    };
  };
  /** Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us. */
  DeleteLicensee: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        licensee: components["schemas"]["LicenseeParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              deleted: number;
            };
            code: 2000;
            message: "Success";
          };
        };
      };
    };
  };
  /** Lists configurations associated with a key */
  ListConfigs: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigsResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
    };
  };
  /** Create a config */
  CreateConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfigNewParam"];
      };
    };
  };
  /** Retrieve config object by name */
  RetrieveConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
  };
  /** Updates configuration object */
  UpdateConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConfigUpdateParam"];
      };
    };
  };
  /** Permanently deletes a configuration object. */
  DeleteConfig: {
    parameters: {
      path: {
        key: components["schemas"]["ApiKeyParam"];
        config: components["schemas"]["ConfigParam"];
      };
      query: {
        user_token: components["schemas"]["UserTokenParam"];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              deleted: number;
            };
            code: 2000;
            message: "Success";
          };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequestResponse"];
        };
      };
      /** Unauthorized Request */
      401: {
        content: {
          "application/json": components["schemas"]["UnauthorizedResponse"];
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["NotFoundResponse"];
        };
      };
    };
  };
}

export interface external {}
